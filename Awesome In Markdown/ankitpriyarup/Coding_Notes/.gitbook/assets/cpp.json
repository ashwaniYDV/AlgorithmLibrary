{
	"Header Information": {
		"prefix": "header",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"#include <ext/pb_ds/trie_policy.hpp>",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;",
			"typedef trie<string, null_type, trie_string_access_traits<>, pat_trie_tag, trie_prefix_search_node_update> pref_trie;",
			"typedef unsigned long long BITMASK; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<double, double> pdd; typedef pair<long long, long long> pll;",
			"#define has_bit(bit_mask, x) ((bit_mask) & (1ULL << (x)))",
			"#define turn_on_bit(bit_mask, x) (bit_mask |= (1ULL << (x)))",
			"#define turn_off_bit(bit_mask, x) (bit_mask &= (~(1ULL << (x))))",
			"#define smallest_on_bit(bit_mask) (__builtin_ctzint((bit_mask) & (-(bit_mask))))",
			"#define CLOCK_START clock_t chrono_clk_beg = clock()",
			"#define CLOCK_END clock_t chrono_clk_end = clock(); cerr << (double(chrono_clk_end - chrono_clk_beg) / CLOCKS_PER_SEC) << \" sec\"",
			"#define bug(args ...) cerr << __LINE__ << \">> \", err(new istringstream(string(#args)), args), cerr << '\\n'",
			"#define decToBin(name, num) string name = bitset<8>(num).to_string();",
			"#define binToDec(name, binary) unsigned long name = bitset<8>(binary).to_ulong();",
			"#define radToDeg(name, radians) double name = radians * 180 / M_PI;",
			"#define all(x) x.begin(), x.end()",
			"#define removeDuplicates(vec) sort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end())",
			"#define printMat(mat) for (auto &x : mat) { for (auto &y : x) { if (y < INF) cout << setw(7) << y; else cout << setw(7) << \"-\"; } cout << '\\n'; }",
			"#define fillMat(mat, n, m, x) for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) mat[i][j] = x;",
			"#define printArr(arr) for (auto &x : arr) cout << x << \" \"; cout << '\\n';",
			"#define arrReplace(arr, from, to) for (auto &x : arr) if (x == from) x = to;",
			"#define INF (1LL<<30)",
			"#define INF32 (1LL<<62)",
			"#define F first",
			"#define S second",
			"#define M_PI 3.14159265358979323846",
			"#define MOD 1000000007",
			"#define int ll",
			"ll powMod(ll a, ll b) { ll x = 1; while (b > 0) { if (b&1) x = (x*a) % MOD; a = (a*a) % MOD; b >>= 1; } return x; }",
			"ll multiply(ll x, ll y) { return ((x % MOD) * (y % MOD)) % MOD; }",
			"ll divide(ll x, ll y) { return ((x % MOD) * powMod(y % MOD, MOD-2)) % MOD; }",
			"inline int ceil(int a, int b) { return (a+b-1)/b; }",
			"void err(istringstream *iss) {} template<typename T, typename ... Args> void err(istringstream *iss, const T &_val, const Args & ... args) { string _name; *iss >> _name; if (_name.back()==',') _name.pop_back(); cerr << _name << \" = \" << _val << \"; \", err(iss, args ...); }",
			"int str_replace(string& str, const string& from, const string& to, int limit = -1) { if(from.empty()) return 0; size_t start_pos = 0; int cnt = 0; while((start_pos = str.find(from, start_pos)) != std::string::npos) { str.replace(start_pos, from.length(), to); start_pos += to.length(); cnt++; if (cnt == limit) break; } return cnt; }",
			"",
			"signed main()",
			"{",
		  "	ios_base::sync_with_stdio(false); cin.tie(NULL);",
		  "	int t;",
		  "	cin >> t;",
		  "	while (t--)",
		  "	{",
		  "	}",
		  "	return 0;",
			"}"
		],
		"description": "Header Information"
	},
	"longestPalindromicManacher": {
		"prefix": "longestPalindromicManacher",
		"body": [
			"string longestPaindromicManacher(string str, int &start, int &end)",
			"{",
			"    int n = str.size();",
			"    if (n == 0) return \"\";",
			"    if (n == 1) return str;",
			"    n = 2*n + 1;",
			"    int L[n];",
			"    L[0] = 0, L[1] = 1;",
			"    int C = 1, R = 2, i = 0, iMirror, maxLPSLength = 0, maxLPSCenterPosition = 0, diff = -1;",
			"    start = -1, end = -1;",
			"    for (i = 2; i < n; i++)",
			"    {",
			"        iMirror = 2*C-i, L[i] = 0, diff = R - i;",
			"        if(diff > 0) L[i] = min(L[iMirror], diff);",
			"        while (((i + L[i]) < n && (i - L[i]) > 0) && (((i + L[i] + 1) % 2 == 0) ||  ",
			"            (str[(i + L[i] + 1)/2] == str[(i - L[i] - 1)/2] )))",
			"        {",
			"            L[i]++;",
			"        }",
			"        if(L[i] > maxLPSLength) maxLPSLength = L[i], maxLPSCenterPosition = i;",
			"        if (i + L[i] > R) C = i, R = i + L[i];",
			"    }",
			"    start = (maxLPSCenterPosition - maxLPSLength)/2;",
			"    end = start + maxLPSLength - 1;",
			"    stringstream ss;",
			"    for (i = start; i <= end; ++i) ss << str[i];",
			"    return ss.str();",
			"}"
		],
		"description": "longestPalindromicManacher"
	},
	"binarySearchRange": {
		"prefix": "binarySearchRange",
		"body": [
			"while (l < r)",
			"{",
			"    int mid = (l+r+1)/2;",
			"    cout << mid << endl;",
			"    if (res == TARG) break;",
			"    else if (res < TARG) l = mid;",
			"    else r = mid-1;",
			"}"
		],
		"description": "binarySearchRange"
	},
	"prefixSum": {
		"prefix": "prefixSum",
		"body": [
			"vector<ll> prefSmArr;",
			"int prefSmInit(vector<ll> &arr)",
			"{",
			"    prefSmArr.resize(arr.size());",
			"    prefSmArr[0] = arr[0];",
			"    for (int i = 1; i < arr.size(); ++i) prefSmArr[i] = arr[i] + prefSmArr[i-1];",
			"}",
			"ll prefSmQuery(int l, int r) { return (l == 0) ? prefSmArr[r] : prefSmArr[r]-prefSmArr[l-1]; }"
		],
		"description": "prefixSum"
	},
	"Header3": {
		"prefix": "header3",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"#include <ext/pb_ds/trie_policy.hpp>",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;",
			"typedef trie<string, null_type, trie_string_access_traits<>, pat_trie_tag, trie_prefix_search_node_update> pref_trie;",
			"typedef unsigned long long BITMASK; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<double, double> pdd; typedef pair<long long, long long> pll;",
			"#define has_bit(bit_mask, x) ((bit_mask) & (1ULL << (x)))",
			"#define turn_on_bit(bit_mask, x) (bit_mask |= (1ULL << (x)))",
			"#define turn_off_bit(bit_mask, x) (bit_mask &= (~(1ULL << (x))))",
			"#define smallest_on_bit(bit_mask) (__builtin_ctzint((bit_mask) & (-(bit_mask))))",
			"#define CLOCK_START clock_t chrono_clk_beg = clock()",
			"#define CLOCK_END clock_t chrono_clk_end = clock(); cerr << (double(chrono_clk_end - chrono_clk_beg) / CLOCKS_PER_SEC) << \" sec\"",
			"#define bug(args ...) cerr << __LINE__ << \">> \", err(new istringstream(string(#args)), args), cerr << '\\n'",
			"#define decToBin(name, num) string name = bitset<8>(num).to_string();",
			"#define binToDec(name, binary) unsigned long name = bitset<8>(binary).to_ulong();",
			"#define radToDeg(name, radians) double name = radians * 180 / M_PI;",
			"#define all(x) x.begin(), x.end()",
			"#define removeDuplicates(vec) sort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end())",
			"#define printMat(mat) for (auto &x : mat) { for (auto &y : x) { if (y < INF) cout << setw(7) << y; else cout << setw(7) << \"-\"; } cout << '\\n'; }",
			"#define fillMat(mat, n, m, x) for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) mat[i][j] = x;",
			"#define printArr(arr) for (auto &x : arr) cout << x << \" \"; cout << '\\n';",
			"#define arrReplace(arr, from, to) for (auto &x : arr) if (x == from) x = to;",
			"#define INF (1LL<<30)",
			"#define INF32 (1LL<<62)",
			"#define F first",
			"#define S second",
			"#define M_PI 3.14159265358979323846",
			"#define MOD 1000000007",
			"#define int ll",
			"ll powMod(ll a, ll b) { ll x = 1; while (b > 0) { if (b&1) x = (x*a) % MOD; a = (a*a) % MOD; b >>= 1; } return x; }",
			"ll multiply(ll x, ll y) { return ((x % MOD) * (y % MOD)) % MOD; }",
			"ll divide(ll x, ll y) { return ((x % MOD) * powMod(y % MOD, MOD-2)) % MOD; }",
			"inline int ceil(int a, int b) { return (a+b-1)/b; }",
			"void err(istringstream *iss) {} template<typename T, typename ... Args> void err(istringstream *iss, const T &_val, const Args & ... args) { string _name; *iss >> _name; if (_name.back()==',') _name.pop_back(); cerr << _name << \" = \" << _val << \"; \", err(iss, args ...); }",
			"int str_replace(string& str, const string& from, const string& to, int limit = -1) { if(from.empty()) return 0; size_t start_pos = 0; int cnt = 0; while((start_pos = str.find(from, start_pos)) != std::string::npos) { str.replace(start_pos, from.length(), to); start_pos += to.length(); cnt++; if (cnt == limit) break; } return cnt; }",
			"",
			"signed main()",
			"{",
		  "	ios_base::sync_with_stdio(false); cin.tie(NULL);",
		  "	int t;",
		  "	cin >> t;",
		  "	int tc = 1;",
		  "	while (t--)",
		  "	{",
		  "		// cout << \"Case #\" << (tc++) << \": \" << ",
		  "	}",
		  "	return 0;",
			"}"
		],
		"description": "Header Information"
	},
	"BIT": {
		"prefix": "BIT",
		"body": [
			"const int N = 1000;",
			"int BIT[N+5];",
			"void update(int i, int val)",
			"{",
		  "	while (i <= N)",
		  "	{",
		  "		BIT[i] += val;",
		  "		i += (i & -i);",
		  "	}",
			"}",
			"int query(int i)",
			"{",
		  "	int sm = 0;",
		  "	while (i)",
		  "	{",
		  "		sm += BIT[i];",
		  "		i -= (i & -i);",
		  "	}",
		  "	return sm;",
			"}",
			"int query(int l, int r) { return query(r) - query(l-1); }",
			"int findWithGivenCumFreq(int curFreq)",
			"{",
		  "	int i = 0;",
		  "	int bitMask = (int)(pow(2, (int)(log2(N))));",
		  "	while (bitMask)",
		  "	{",
		  "		int temp = i + bitMask;",
			"        bitMask >>= 1;",
			"        if (temp > N) continue;",
			"        if (curFreq == BIT[temp]) return temp;",
			"        else if (curFreq > BIT[temp]) i = temp, curFreq -= BIT[temp];",
		  "	}",
		  "	if (curFreq != 0) return -1;",
		  "	else return i;",
			"}"
		],
		"description": "BIT"
	},
	"2DBIT": {
		"prefix": "2DBIT",
		"body": [
			"const int X = 1000, Y = 1000;",
			"int BIT[X+5][Y+5];",
			"void update(int x, int y, int val)",
			"{",
			"    while (x <= X)",
			"    {",
			"        int _y = y;",
			"        while (_y <= Y) BIT[x][_y] += val, _y += (_y & -_y);",
			"        x += (x & -x);",
			"    }",
			"}",
			"int query(int x, int y)",
			"{",
			"    int sm = 0;",
			"    while (x)",
			"    {",
			"        int _y = y;",
			"        while (_y) sm += BIT[x][_y], _y -= (_y & -_y);",
			"        x -= (x & -x);",
			"    }",
			"    return sm;",
			"}"
		],
		"description": "2DBIT"
	},
	"BigInt": {
		"prefix": "bigInt",
		"body": [
			"const int base = 1000000000, base_digits = 9;",
			"struct BigInt",
			"{",
			"    vector<int> a;",
			"    int sign;",
			"",
			"    BigInt() : sign(1) { }",
			"    BigInt(ll v) { *this = v; }",
			"    BigInt(const string &s) { read(s); }",
			"    void operator=(const BigInt &v) { sign = v.sign; a = v.a; }",
			"    BigInt operator*(int v) const { BigInt res = *this; res *= v; return res; }",
			"    BigInt operator/(const BigInt &v) const { return divmod(*this, v).first; }",
			"    BigInt operator%(const BigInt &v) const { return divmod(*this, v).second; }",
			"    BigInt operator/(int v) const { BigInt res = *this; res /= v; return res; }",
			"    void operator+=(const BigInt &v) { *this = *this + v; }",
			"    void operator-=(const BigInt &v) { *this = *this - v; }",
			"    void operator*=(const BigInt &v) { *this = *this * v; }",
			"    void operator/=(const BigInt &v) { *this = *this / v; }",
			"    bool operator>(const BigInt &v) const { return v < *this; }",
			"    bool operator<=(const BigInt &v) const { return !(v < *this); }",
			"    bool operator>=(const BigInt &v) const { return !(*this < v); }",
			"    bool operator==(const BigInt &v) const { return !(*this < v) && !(v < *this); }",
			"    bool operator!=(const BigInt &v) const { return *this < v || v < *this; }",
			"    bool isZero() const { return a.empty() || (a.size() == 1 && !a[0]); }",
			"    void trim()",
			"    {",
			"        while (!a.empty() && !a.back()) a.pop_back();",
			"        if (a.empty()) sign = 1;",
			"    }",
			"    BigInt operator-() const",
			"    {",
			"        BigInt res = *this;",
			"        res.sign = -sign;",
			"        return res;",
			"    }",
			"    BigInt abs() const",
			"    {",
			"        BigInt res = *this;",
			"        res.sign *= res.sign;",
			"        return res;",
			"    }",
			"    void operator=(ll v)",
			"    {",
			"        sign = 1;",
			"        if (v < 0) sign = -1, v = -v;",
			"        for (; v > 0; v = v / base) a.push_back(v % base);",
			"    }",
			"    int operator%(int v) const",
			"    {",
			"        if (v < 0) v = -v;",
			"        int m = 0;",
			"        for (int i = a.size() - 1; i >= 0; --i) m = (a[i] + m * (ll)base) % v;",
			"        return m * sign;",
			"    }",
			"    BigInt operator+(const BigInt &v) const",
			"    {",
			"        if (sign == v.sign)",
			"        {",
			"            BigInt res = v;",
			"            for (int i = 0, carry = 0; i < (int)max(a.size(), v.a.size()) || carry; ++i)",
			"            {",
			"                if (i == (int)res.a.size()) res.a.push_back(0);",
			"                res.a[i] += carry + (i < (int)a.size() ? a[i] : 0);",
			"                carry = res.a[i] >= base;",
			"                if (carry) res.a[i] -= base;",
			"            }",
			"            return res;",
			"        }",
			"        return *this - (-v);",
			"    }",
			"",
			"    BigInt operator-(const BigInt &v) const",
			"    {",
			"        if (sign == v.sign)",
			"        {",
			"            if (abs() >= v.abs())",
			"            {",
			"                BigInt res = *this;",
			"                for (int i = 0, carry = 0; i < (int)v.a.size() || carry; ++i)",
			"                {",
			"                    res.a[i] -= carry + (i < (int)v.a.size() ? v.a[i] : 0);",
			"                    carry = res.a[i] < 0;",
			"                    if (carry) res.a[i] += base;",
			"                }",
			"                res.trim();",
			"                return res;",
			"            }",
			"            return -(v - *this);",
			"        }",
			"        return *this + (-v);",
			"    }",
			"",
			"    void operator*=(int v)",
			"    {",
			"        if (v < 0) sign = -sign, v = -v;",
			"        for (int i = 0, carry = 0; i < (int)a.size() || carry; ++i)",
			"        {",
			"            if (i == (int)a.size()) a.push_back(0);",
			"            ll cur = a[i] * (ll)v + carry;",
			"            carry = (int)(cur / base);",
			"            a[i] = (int)(cur % base);",
			"            //asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
			"        }",
			"        trim();",
			"    }",
			"",
			"    friend pair<BigInt, BigInt> divmod(const BigInt &a1, const BigInt &b1)",
			"    {",
			"        int norm = base / (b1.a.back() + 1);",
			"        BigInt a = a1.abs() * norm, b = b1.abs() * norm, q, r;",
			"        q.a.resize(a.a.size());",
			"        for (int i = a.a.size() - 1; i >= 0; i--)",
			"        {",
			"            r *= base, r += a.a[i];",
			"            int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
			"            int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
			"            int d = ((ll)base * s1 + s2) / b.a.back();",
			"            r -= b * d;",
			"            while (r < 0) r += b, --d;",
			"            q.a[i] = d;",
			"        }",
			"        q.sign = a1.sign * b1.sign, r.sign = a1.sign;",
			"        q.trim(); r.trim();",
			"        return make_pair(q, r / norm);",
			"    }",
			"    void operator/=(int v)",
			"    {",
			"        if (v < 0) sign = -sign, v = -v;",
			"        for (int i = (int)a.size() - 1, rem = 0; i >= 0; --i)",
			"        {",
			"            ll cur = a[i] + rem * (ll)base;",
			"            a[i] = (int)(cur / v);",
			"            rem = (int)(cur % v);",
			"        }",
			"        trim();",
			"    }",
			"    bool operator<(const BigInt &v) const",
			"    {",
			"        if (sign != v.sign) return sign < v.sign;",
			"        if (a.size() != v.a.size()) return a.size() * sign < v.a.size() * v.sign;",
			"        for (int i = a.size() - 1; i >= 0; i--)",
			"            if (a[i] != v.a[i]) return a[i] * sign < v.a[i] * sign;",
			"        return false;",
			"    }",
			"    void read(const string &s)",
			"    {",
			"        sign = 1;",
			"        a.clear();",
			"        int pos = 0;",
			"        while (pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+'))",
			"        {",
			"            if (s[pos++] == '-') sign = -sign;",
			"        }",
			"        for (int i = s.size() - 1; i >= pos; i -= base_digits)",
			"        {",
			"            int x = 0;",
			"            for (int j = max(pos, i - base_digits + 1); j <= i; j++) x = x * 10 + s[j] - '0';",
			"            a.push_back(x);",
			"        }",
			"        trim();",
			"    }",
			"    friend istream &operator>>(istream &stream, BigInt &v)",
			"    {",
			"        string s;",
			"        stream >> s;",
			"        v.read(s);",
			"        return stream;",
			"    }",
			"    string toString()",
			"    {",
			"        stringstream stream;",
			"        if (sign == -1) stream << '-';",
			"        stream << (a.empty() ? 0 : a.back());",
			"        for (int i = (int)a.size() - 2; i >= 0; --i) stream << setw(base_digits) << setfill('0') << a[i];",
			"        return stream.str();",
			"    }",
			"    friend ostream &operator<<(ostream &stream, const BigInt &v)",
			"    {",
			"        if (v.sign == -1) stream << '-';",
			"        stream << (v.a.empty() ? 0 : v.a.back());",
			"        for (int i = (int)v.a.size() - 2; i >= 0; --i) stream << setw(base_digits) << setfill('0') << v.a[i];",
			"        return stream;",
			"    }",
			"    static vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits)",
			"    {",
			"        vector<ll> p(max(old_digits, new_digits) + 1);",
			"        p[0] = 1;",
			"        for (int i = 1; i < (int)p.size(); i++) p[i] = p[i - 1] * 10;",
			"        vector<int> res;",
			"        ll cur = 0;",
			"        int cur_digits = 0;",
			"        for (int i = 0; i < (int)a.size(); i++)",
			"        {",
			"            cur += a[i] * p[cur_digits];",
			"            cur_digits += old_digits;",
			"            while (cur_digits >= new_digits)",
			"            {",
			"                res.push_back(int(cur % p[new_digits]));",
			"                cur /= p[new_digits];",
			"                cur_digits -= new_digits;",
			"            }",
			"        }",
			"        res.push_back((int)cur);",
			"        while (!res.empty() && !res.back()) res.pop_back();",
			"        return res;",
			"    }",
			"    static vector<ll> karatsubaMultiply(const vector<ll> &a, const vector<ll> &b)",
			"    {",
			"        int n = a.size();",
			"        vector<ll> res(n + n);",
			"        if (n <= 32)",
			"        {",
			"            for (int i = 0; i < n; i++)",
			"                for (int j = 0; j < n; j++) res[i + j] += a[i] * b[j];",
			"            return res;",
			"        }",
			"        int k = n >> 1;",
			"        vector<ll> a1(a.begin(), a.begin() + k);",
			"        vector<ll> a2(a.begin() + k, a.end());",
			"        vector<ll> b1(b.begin(), b.begin() + k);",
			"        vector<ll> b2(b.begin() + k, b.end());",
			"        vector<ll> a1b1 = karatsubaMultiply(a1, b1);",
			"        vector<ll> a2b2 = karatsubaMultiply(a2, b2);",
			"        for (int i = 0; i < k; i++) a2[i] += a1[i];",
			"        for (int i = 0; i < k; i++) b2[i] += b1[i];",
			"        vector<ll> r = karatsubaMultiply(a2, b2);",
			"        for (int i = 0; i < (int)a1b1.size(); i++) r[i] -= a1b1[i];",
			"        for (int i = 0; i < (int)a2b2.size(); i++) r[i] -= a2b2[i];",
			"        for (int i = 0; i < (int)r.size(); i++) res[i + k] += r[i];",
			"        for (int i = 0; i < (int)a1b1.size(); i++) res[i] += a1b1[i];",
			"        for (int i = 0; i < (int)a2b2.size(); i++) res[i + n] += a2b2[i];",
			"        return res;",
			"    }",
			"    BigInt operator*(const BigInt &v) const",
			"    {",
			"        vector<int> a6 = convert_base(this->a, base_digits, 6);",
			"        vector<int> b6 = convert_base(v.a, base_digits, 6);",
			"        vector<ll> a(a6.begin(), a6.end());",
			"        vector<ll> b(b6.begin(), b6.end());",
			"        while (a.size() < b.size()) a.push_back(0);",
			"        while (b.size() < a.size()) b.push_back(0);",
			"        while (a.size() & (a.size() - 1)) a.push_back(0), b.push_back(0);",
			"        vector<ll> c = karatsubaMultiply(a, b);",
			"        BigInt res;",
			"        res.sign = sign * v.sign;",
			"        for (int i = 0, carry = 0; i < (int)c.size(); i++)",
			"        {",
			"            ll cur = c[i] + carry;",
			"            res.a.push_back((int)(cur % 1000000));",
			"            carry = (int)(cur / 1000000);",
			"        }",
			"        res.a = convert_base(res.a, 6, base_digits);",
			"        res.trim();",
			"        return res;",
			"    }",
			"};",
			"BigInt __gcd(BigInt a, BigInt b) { return b == 0 ? a : __gcd(b, a - (a / b) * b); }"
		],
		"description": "BigInt"
	},
	"segmentTree": {
		"prefix": "segmentTree",
		"body": [
			"const int N = 1e6;",
			"int n, segmentTree[2*N];",
			"void build()",
			"{",
			"    for (int i = n-1; i > 0; --i)",
			"        segmentTree[i] = segmentTree[i<<1] + segmentTree[i<<1|1];",
			"}",
			"void modify(int p, int value)",
			"{",
			"    for (segmentTree[p += n] = value; p > 1; p >>= 1)",
			"        segmentTree[p>>1] = segmentTree[p] + segmentTree[p^1];",
			"}",
			"int query(int l, int r)",
			"{",
			"    int res = 0;",
			"    for (l += n, r += n; l < r; l >>= 1, r >>= 1)",
			"    {",
			"        if (l&1) res += segmentTree[l++];",
			"        if (r&1) res += segmentTree[--r];",
			"    }",
			"    return res;",
			"}"
		],
		"description": "segmentTree"
	},
	"header2": {
		"prefix": "header2",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"#include <ext/pb_ds/trie_policy.hpp>",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"typedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;",
			"typedef trie<string, null_type, trie_string_access_traits<>, pat_trie_tag, trie_prefix_search_node_update> pref_trie;",
			"typedef unsigned long long BITMASK; typedef long long ll; typedef long double ld; typedef pair<int, int> pii; typedef pair<double, double> pdd; typedef pair<long long, long long> pll;",
			"#define has_bit(bit_mask, x) ((bit_mask) & (1ULL << (x)))",
			"#define turn_on_bit(bit_mask, x) (bit_mask |= (1ULL << (x)))",
			"#define turn_off_bit(bit_mask, x) (bit_mask &= (~(1ULL << (x))))",
			"#define smallest_on_bit(bit_mask) (__builtin_ctzint((bit_mask) & (-(bit_mask))))",
			"#define CLOCK_START clock_t chrono_clk_beg = clock()",
			"#define CLOCK_END clock_t chrono_clk_end = clock(); cerr << (double(chrono_clk_end - chrono_clk_beg) / CLOCKS_PER_SEC) << \" sec\"",
			"#define bug(args ...) cerr << __LINE__ << \">> \", err(new istringstream(string(#args)), args), cerr << '\\n'",
			"#define decToBin(name, num) string name = bitset<8>(num).to_string();",
			"#define binToDec(name, binary) unsigned long name = bitset<8>(binary).to_ulong();",
			"#define radToDeg(name, radians) double name = radians * 180 / M_PI;",
			"#define all(x) x.begin(), x.end()",
			"#define removeDuplicates(vec) sort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end())",
			"#define printMat(mat) for (auto &x : mat) { for (auto &y : x) { if (y < INF) cout << setw(7) << y; else cout << setw(7) << \"-\"; } cout << '\\n'; }",
			"#define fillMat(mat, n, m, x) for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) mat[i][j] = x;",
			"#define printArr(arr) for (auto &x : arr) cout << x << \" \"; cout << '\\n';",
			"#define arrReplace(arr, from, to) for (auto &x : arr) if (x == from) x = to;",
			"#define INF (1LL<<30)",
			"#define INF32 (1LL<<62)",
			"#define F first",
			"#define S second",
			"#define M_PI 3.14159265358979323846",
			"#define MOD 1000000007",
			"#define int ll",
			"ll powMod(ll a, ll b) { ll x = 1; while (b > 0) { if (b&1) x = (x*a) % MOD; a = (a*a) % MOD; b >>= 1; } return x; }",
			"ll multiply(ll x, ll y) { return ((x % MOD) * (y % MOD)) % MOD; }",
			"ll divide(ll x, ll y) { return ((x % MOD) * powMod(y % MOD, MOD-2)) % MOD; }",
			"inline int ceil(int a, int b) { return (a+b-1)/b; }",
			"void err(istringstream *iss) {} template<typename T, typename ... Args> void err(istringstream *iss, const T &_val, const Args & ... args) { string _name; *iss >> _name; if (_name.back()==',') _name.pop_back(); cerr << _name << \" = \" << _val << \"; \", err(iss, args ...); }",
			"int str_replace(string& str, const string& from, const string& to, int limit = -1) { if(from.empty()) return 0; size_t start_pos = 0; int cnt = 0; while((start_pos = str.find(from, start_pos)) != std::string::npos) { str.replace(start_pos, from.length(), to); start_pos += to.length(); cnt++; if (cnt == limit) break; } return cnt; }",
			"",
			"signed main()",
			"{",
			"    ios_base::sync_with_stdio(false); cin.tie(NULL);",
			"    return 0;",
			"}"
		],
		"description": "header2"
	},
	"countInInterval": {
		"prefix": "countInInterval",
		"body": [
			"int countInInterval(int x1, int y1, int x2, int y2)",
			"{",
			"    int sz = max({x1, x2, y1, y2}) - min({x1, x2, y1, y2}) + 1;",
			"    int sz_a = y1-x1+1, sz_b = y2-x2+1;",
			"    if (sz_a + sz_b - 1 == sz) return 1;",
			"    else if (sz_a + sz_b -1 < sz) return 0;",
			"    else return (sz_a + sz_b - sz);",
			"}"
		],
		"description": "countInInterval"
	},
	"topologicalSort": {
		"prefix": "topologicalSort",
		"body": [
			"vector<int> topologicalSort(int n, vector<int> adj[])",
			"{",
			"    vector<int> inDeg(n, 0);",
			"    for (int i = 0; i < n; ++i)",
			"        for (auto &x : adj[i]) ++inDeg[x];",
			"    queue<int> q;",
			"    for (int i = 0; i < n; ++i)",
			"        if (inDeg[i] == 0) q.push(i);",
			"    vector<int> topOrder;",
			"    while (!q.empty())",
			"    {",
			"        auto cur = q.front();",
			"        q.pop();",
			"        topOrder.push_back(cur);",
			"        for (auto &x : adj[cur])",
			"        {",
			"            --inDeg[x];",
			"            if (inDeg[x] == 0) q.push(x);",
			"        }",
			"    }",
			"    return topOrder;",
			"}"
		],
		"description": "topologicalSort"
	},
	"eulertotient": {
		"prefix": "eulertotient",
		"body": [
			"int totient(int x)",
			"{",
			"    int ret = x;",
			"    for (int i = 2; i*i <= x; ++i)",
			"    {",
			"        if (x%i == 0)",
			"        {",
			"            ret = ret / i*(i-1);",
			"            while (x % i == 0) x /= i;",
			"        }",
			"    }",
			"    if (x > 1) ret = ret / x*(x-1);",
			"    return ret;",
			"}"
		],
		"description": "eulertotient"
	},
	"Array Input": {
		"prefix": "arrayInp",
		"body": [
			"int n;",
			"cin >> n;",
			"vector<int> arr(n);",
			"for (int i = 0; i < n; ++i) cin >> arr[i];"
		],
		"description": "Array Input"
	},
	"Difference Array": {
		"prefix": "differenceArray",
		"body": [
			"class DifferenceArray",
			"{",
			"public:",
			"    vector<int> arr;",
			"    DifferenceArray(int n) { arr.resize(n); }",
			"    void update(int l, int r, int val)",
			"    {",
			"        if (l >= arr.size() || l < 0 || r < l) return;",
			"        arr[l] += val;",
			"        if (r+1 < arr.size()) arr[r+1] -= val;",
			"    }",
			"    vector<int> query()",
			"    {",
			"        vector<int> res(arr.size());",
			"        for (int i = 0; i < arr.size(); ++i)",
			"            res[i] = (i == 0) ? arr[i] : arr[i] + res[i-1];",
			"        return res;",
			"    }",
			"};"
		],
		"description": "Difference Array"
	},
	"Array Input Max Min": {
		"prefix": "arrayInpMAXMIN",
		"body": [
			"int n;",
			"cin >> n;",
			"vector<int> arr(n);",
			"int mn = LONG_MAX, mx = LONG_MIN;",
			"for (int i = 0; i < n; ++i) { cin >> arr[i]; mn = min(mn, arr[i]); mx = max(mx, arr[i]); }"
		],
		"description": "Array Input Max Min"
	},
	"Divisor": {
		"prefix": "divisor",
		"body": [
			"vector<ll> findDivisors(ll n)",
			"{",
			"    vector<ll> res;",
			"    for (ll i = 1; i <= sqrt(n); ++i)",
			"    {",
			"        if (n%i == 0)",
			"        {",
			"            res.push_back(i);",
			"            if (n/i != i) res.push_back(n/i);",
			"        }",
			"    }",
			"    return res;",
			"}"
		],
		"description": "Divisor"
	},
	"prime factors": {
		"prefix": "primefactors",
		"body": [
			"vector<ll> primeFactors(ll n)",
			"{",
			"    vector<ll> res;",
			"    while (n%2 == 0) { res.push_back(2); n /= 2; }",
			"    for (int i = 3; i <= sqrt(n); i += 2)",
			"        while (n % i == 0) { res.push_back(i); n /= i; }",
			"    if (n > 2) res.push_back(n);",
			"    return res;",
			"}"
		],
		"description": "prime factors"
	},
	"sieve": {
		"prefix": "sieve",
		"body": [
			"ll sieve[2000005];",
			"set<int> primes;",
			"void makeSieve()",
			"{",
			"    fill(sieve, sieve + 2000005, 1);",
			"    sieve[0] = 0;",
			"    sieve[1] = 0;",
			"    for (int i = 2; i < 2000005; ++i)",
			"    {",
			"        if (sieve[i] == 1)",
			"        {",
			"            for (int j = i*2; j < 2000005; j+=i)",
			"                sieve[j] = 0;",
			"        }",
			"    }",
			"    for (int i = 0; i < 2000005; ++i)",
			"        if (sieve[i]) primes.insert(i);",
			"}"
		],
		"description": "sieve"
	},
	"LIS": {
		"prefix": "lis",
		"body": [
			"int LIS(vector<int>& nums)",
			"{",
			"    set<int> st;",
			"    for (int i = 0; i < nums.size(); ++i)",
			"    {",
			"        if (st.lower_bound(nums[i]) != st.end())",
			"            st.erase(st.lower_bound(nums[i]));",
			"        st.insert(nums[i]);",
			"    }",
			"    return st.size();",
			"}"
		],
		"description": "LIS"
	},
	"modularArithematic": {
		"prefix": "modularArithematic",
		"body": [
			"class ModularArithematic",
			"{",
			"private:",
			"    static pair<ll, ll> chineaseRemainderTheorem(ll x, ll a, ll y, ll b)",
			"    {",
			"        ll s, t, d = extendedEuclid(x, y, s, t);",
			"        if (a%d != b%d) return make_pair(0, -1);",
			"        return make_pair(((s*b*x + t*a*y + x*y)%(x*y))/d, x*y/d);",
			"    }",
			" ",
			"public:",
			"    static ll __lcm (ll a, ll b) { return (a/__gcd(a,b)*b); }",
			"    static ll powerMod(ll a, ll b)",
			"    {",
			"        ll x = 1;",
			"        while (b > 0)",
			"        {",
			"            #ifdef MOD",
			"            if (b&1) x = (x*a) % MOD;",
			"            a = (a*a) % MOD;",
			"            #else",
			"            if (b&1) x *= a;",
			"            a *= a;",
			"            #endif",
			"            b >>= 1;",
			"        }",
			"        return x;",
			"    }",
			"    static ll multiplyMod(ll a, ll b)",
			"    {",
			"        #ifdef MOD",
			"        ll res = 0;",
			"        while(b)",
			"        {",
			"            if (b&1)",
			"            {",
			"                res += a;",
			"                if (res >= MOD) res -= MOD;",
			"            }",
			"            b >>= 1;",
			"            a = (a << 1);",
			"            if (a >= MOD) a-= MOD;",
			"        }",
			"        return res;",
			"        #else",
			"        return a*b;",
			"        #endif",
			"    }",
			"    static ll inverseMod(ll a, ll m)",
			"    {",
			"        a = a % m;",
			"        for (ll x = 1; x < m; x++)",
			"        {",
			"            if ((a * x) % m == 1)",
			"                return x;",
			"        }",
			"        return -1;",
			"    }",
			"    static ll nCr(ll n, ll r)",
			"    {",
			"        if (n < r) return 0;",
			"        ll res = 1, rem = 1;",
			"        for (ll i = n - r + 1; i <= n; i++) res = multiplyMod(res, i);",
			"        for (ll i = 2; i <= r; i++) rem = multiplyMod(rem, i);",
			"        return multiplyMod(res, powerMod(rem, MOD - 2));",
			"    }",
			"    // returns d = gcd(a,b); finds x,y such that d = ax + by",
			"    static ll extendedEuclid(ll a, ll b, ll &x, ll &y)",
			"    {",
			"        ll xx = y = 0;",
			"        ll yy = x = 1;",
			"        while (b)",
			"        {",
			"            ll q = a/b;",
			"            ll t = b; b = a%b; a = t;",
			"            t = xx; xx = x-q*xx; x = t;",
			"            t = yy; yy = y-q*yy; y = t;",
			"        }",
			"        return a;",
			"    }",
			"    // finds all solutions to ax = b (mod n)",
			"    static vector<ll> modularLinearEquationSolver(ll a, ll b, ll n)",
			"    {",
			"        ll x, y;",
			"        vector<ll> solutions;",
			"        ll d = extendedEuclid(a, n, x, y);",
			"        if (b%d == 0)",
			"        {",
			"            x = ((x * (b/d) + n) % n);",
			"            for (ll i = 0; i < d; ++i)",
			"                solutions.push_back((x + i*(n/d) + n) % n);",
			"        }",
			"        return solutions;",
			"    }",
			"    // computes x and y such that ax + by = c; on failure, x = y =-1",
			"    static void linearDiophantine(ll a, ll b, ll c, ll &x, ll &y)",
			"    {",
			"        ll d = __gcd(a, b);",
			"        if (c%d) x = y = -1;",
			"        else",
			"        {",
			"            x = c/d * inverseMod(a/d, b/d);",
			"            y = (c-a*x)/b;",
			"        }",
			"    }",
			"    // finds z such that z % x[i] = a[i] for all i. returns (z, M) on failure M = -1",
			"    // Note: we require a[i]'s to be relatively prime",
			"    static pair<ll, ll> chineaseRemainderTheorem(const vector<ll> &x, const vector<ll> &a)",
			"    {",
			"        pair<ll, ll> ret = make_pair(x[0], a[0]);",
			"        for (int i = 1; i < x.size(); ++i)",
			"        {",
			"            ret = chineaseRemainderTheorem(ret.first, ret.second, x[i], a[i]);",
			"            if (ret.second == -1) break;",
			"        }",
			"        return ret;",
			"    }",
			" ",
			"    static void nCrPreprocess(int size, vector<int> &fact, vector<int> &inv)",
			"    {",
			"        fact.resize(size + 5);",
			"        inv.resize(size + 5);",
			"        fact[0] = inv[0] = 1;",
			"        for(int i = 1; i < size; ++i)",
			"        {",
			"            fact[i] = multiplyMod(fact[i-1], i);",
			"            inv[i] = powerMod(fact[i], MOD-2);",
			"        }",
			"    }",
			" ",
			"    static int nCrQuery(int n, int r, vector<int> &fact, vector<int> &inv)",
			"    {",
			"        if (n < r) return 0;",
			"        int res = 1; res = multiplyMod(res, fact[n]);",
			"        res = multiplyMod(res, inv[r]);",
			"        res = multiplyMod(res, inv[n-r]);",
			"        return res;",
			"    }",
			"};"
		],
		"description": "dayOfWeek"
	},
	"Matrix Helper": {
		"prefix": "matrix",
		"body": [
			"template <typename T>",
			"class Matrix",
			"{",
			"public:",
		  "	vector< vector<T> > mat;",
		  "	int rows, columns;",
		  "	Matrix() : rows(0), columns(0) {}",
		  "	Matrix(int _r, int _c) : rows(_r), columns(_c) { mat.assign(rows, vector<T>(columns)); }",
		  "	Matrix(int _r, int _c, const T &val) : rows(_r), columns(_c) { mat.assign(rows, vector<T>(columns, val)); }",
		  "	Matrix(int _n) : rows(_n), columns(_n)",
		  "	{",
		  "		mat.assign(_n, vector<T>(_n));",
		  "		for (int i = 0; i < _n; ++i) mat[i][i] = (T)1;",
		  "	}",
		  "	void display(int space = 5)",
		  "	{",
		  "		for (auto &x : mat)",
		  "		{",
		  "			for (auto &y : x) cout << setw(space) << y;",
		  "			cout << '\\n';",
		  "		}",
		  "	}",
		  "	Matrix operator *(const Matrix<T> &B)",
		  "	{",
		  "		assert(columns == B.rows);",
		  "		Matrix<T> C(rows, B.columns, 0);",
		  "		for (int i = 0; i < rows; ++i)",
		  "		{",
		  "			for (int j = 0; j < B.columns; ++j)",
		  "			{",
		  "				for (int k = 0; k < columns; ++k)",
		  "				{",
		  "					#ifdef MOD",
		  "					C.mat[i][j] = (C.mat[i][j] + ((mat[i][k] * B.mat[k][j]) % MOD)) % MOD;",
		  "					#else",
		  "					C.mat[i][j] += mat[i][k] * B.mat[k][j];",
		  "					#endif",
		  "				}",
		  "			}",
		  "		}",
		  "		return C;",
		  "	}",
		  "	Matrix operator *(ll x)",
		  "	{",
		  "		Matrix<T> C(rows, columns);",
		  "		for (int i = 0; i < rows; ++i)",
		  "		{",
		  "			for (int j = 0; j < rows; ++j)",
		  "			{",
		  "				#ifdef MOD",
		  "				C.mat[i][j] = (mat[i][j] * x) % MOD;",
		  "				#else",
		  "				C.mat[i][j] = mat[i][j] * x;",
		  "				#endif",
		  "			}",
		  "		}",
		  "		return C;",
		  "	}",
		  "	Matrix operator +(const Matrix<T> &B)",
		  "	{",
		  "		assert(rows == B.rows); assert(columns == B.columns);",
		  "		Matrix <T> C(rows, columns, 0);",
		  "		for (int i = 0; i < rows; ++i)",
		  "		{",
		  "			for (int j = 0; j < columns; ++j)",
		  "			{",
		  "				#ifdef MOD",
		  "				C.mat[i][j] = (mat[i][j] + B.mat[i][j]) % MOD;",
		  "				#else",
		  "				C.mat[i][j] = mat[i][j] + B.mat[i][j];",
		  "				#endif",
		  "			}",
		  "		}",
		  "		return C;",
		  "	}",
		  "	Matrix operator -(const Matrix<T> &B)",
		  "	{",
		  "		assert(rows == B.rows); assert(columns == B.columns);",
		  "		Matrix <T> C(rows, columns, 0);",
		  "		for (int i = 0; i < rows; ++i)",
		  "		{",
		  "			for (int j = 0; j < columns; ++j)",
		  "			{",
		  "				#ifdef MOD",
		  "				C.mat[i][j] = (mat[i][j] - B.mat[i][j] + MOD) % MOD;",
		  "				#else",
		  "				C.mat[i][j] = mat[i][j] - B.mat[i][j];",
		  "				#endif",
		  "			}",
		  "		}",
		  "		return C;",
		  "	}",
		  "	Matrix operator^(ll n)",
		  "	{",
		  "		assert(rows == columns);",
		  "		Matrix<T> C(rows), X(rows, columns, 0);",
		  "		for (int i = 0; i < rows; ++i)",
		  "			for (int j = 0; j < columns; ++j)",
		  "				X.mat[i][j] = mat[i][j];",
		  "		while (n)",
		  "		{",
		  "			if (n&1) C *= X;",
		  "			X *= X;",
		  "			n /= 2;",
		  "		}",
		  "		return C;",
		  "	}",
		  "	Matrix transpose()",
		  "	{",
		  "		Matrix<T> res(columns, rows);",
		  "		for (int i = 0; i < columns; ++i)",
		  "			for (int j = 0; j < rows; ++j)",
		  "				res[i][j] = mat[j][i];",
		  "		return res;",
		  "	}",
		  "	void operator *=(const Matrix<T> &B) { auto res = operator*(B); rows = res.rows, columns = res.columns, mat = res.mat; }",
		  "	void operator *=(ll x) { auto res = operator*(x); rows = res.rows, columns = res.columns, mat = res.mat; }",
		  "	void operator +=(const Matrix<T> &B) { auto res = operator+(B); rows = res.rows, columns = res.columns, mat = res.mat; }",
		  "	void operator -=(const Matrix<T> &B) { auto res = operator-(B); rows = res.rows, columns = res.columns, mat = res.mat; }",
		  "	void operator ^=(ll x) { auto res = operator^(x); rows = res.rows, columns = res.columns, mat = res.mat; }",
		  "	void transposeInplace() { auto res = transpose(); rows = res.rows, columns = res.columns, mat = res.mat; }",
			"};"
		],
		"description": "Matrix Helper"
	},
	"Kaden": {
		"prefix": "kaden",
		"body": [
			"struct kaden_ans { int l, r, val; };",
			"kaden_ans kaden(vector<int> &arr, int l, int r, bool canBeEmpty = true, bool product = false)",
			"{",
			"    vector<int> kaden(r-l+1);",
			"    kaden[0] = arr[l];",
			"    int res = kaden[0], maxV = kaden[0], minV = kaden[0], _r = 0, _l = 0;",
			"    for (int i = 1; i < kaden.size(); ++i)",
			"    {",
			"        if (product)",
			"        {",
			"            int prev = maxV;",
			"            maxV = max({minV * arr[l+i], prev * arr[l+i], arr[l+i]});",
			"            minV = min({minV * arr[l+i], prev * arr[l+i], arr[l+i]});",
			"            if (maxV > res) res = maxV, _r = l+i;",
			"        }",
			"        else",
			"        {",
			"            kaden[i] = max(arr[l+i], arr[l+i] + kaden[i-1]);",
			"            if (kaden[i] > res) res = kaden[i], _r = l+i;",
			"        }",
			"    }",
			"    if (canBeEmpty && res < 0) return {-1, -1, 0};",
			"    int cur = 0;",
			"    for (int i = _r; i >= 0; --i)",
			"    {",
			"        if (product) cur *= arr[i];",
			"        else cur += arr[i];",
			"        if (cur == res) _l = i;",
			"    }",
			"    return {_l, _r, res};",
			"}"
		],
		"description": "Kaden"
	},
	"NTT": {
		"prefix": "ntt",
		"body": [
			"#pragma region NTT",
			"template <typename T>",
			"class Modular",
			"{",
			"public:",
		  "	using Type = typename decay<decltype(T::value)>::type;",
			"",
		  "	constexpr Modular() : value() {}",
		  "	template <typename U>",
		  "	Modular(const U &x)",
		  "	{",
		  "		value = normalize(x);",
		  "	}",
			"",
		  "	template <typename U>",
		  "	static Type normalize(const U &x)",
		  "	{",
		  "		Type v;",
		  "		if (-mod() <= x && x < mod())",
		  "			v = static_cast<Type>(x);",
		  "		else",
		  "			v = static_cast<Type>(x % mod());",
		  "		if (v < 0)",
		  "			v += mod();",
		  "		return v;",
		  "	}",
			"",
		  "	const Type &operator()() const { return value; }",
		  "	template <typename U>",
		  "	explicit operator U() const { return static_cast<U>(value); }",
		  "	constexpr static Type mod() { return T::value; }",
			"",
		  "	Modular &operator+=(const Modular &other)",
		  "	{",
		  "		if ((value += other.value) >= mod())",
		  "			value -= mod();",
		  "		return *this;",
		  "	}",
		  "	Modular &operator-=(const Modular &other)",
		  "	{",
		  "		if ((value -= other.value) < 0)",
		  "			value += mod();",
		  "		return *this;",
		  "	}",
		  "	template <typename U>",
		  "	Modular &operator+=(const U &other) { return *this += Modular(other); }",
		  "	template <typename U>",
		  "	Modular &operator-=(const U &other) { return *this -= Modular(other); }",
		  "	Modular &operator++() { return *this += 1; }",
		  "	Modular &operator--() { return *this -= 1; }",
		  "	Modular operator++(int)",
		  "	{",
		  "		Modular result(*this);",
		  "		*this += 1;",
		  "		return result;",
		  "	}",
		  "	Modular operator--(int)",
		  "	{",
		  "		Modular result(*this);",
		  "		*this -= 1;",
		  "		return result;",
		  "	}",
		  "	Modular operator-() const { return Modular(-value); }",
			"",
		  "	template <typename U = T>",
		  "	typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type &operator*=(const Modular &rhs)",
		  "	{",
			"#ifdef _WIN32",
		  "		uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);",
		  "		uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;",
		  "		asm(",
		  "			\"divl %4; \\n\\t\"",
		  "			: \"=a\"(d), \"=d\"(m)",
		  "			: \"d\"(xh), \"a\"(xl), \"r\"(mod()));",
		  "		value = m;",
			"#else",
		  "		value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
			"#endif",
		  "		return *this;",
		  "	}",
		  "	template <typename U = T>",
		  "	typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs)",
		  "	{",
		  "		int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());",
		  "		value = normalize(value * rhs.value - q * mod());",
		  "		return *this;",
		  "	}",
		  "	template <typename U = T>",
		  "	typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs)",
		  "	{",
		  "		value = normalize(value * rhs.value);",
		  "		return *this;",
		  "	}",
			"",
		  "	Modular inverse() const",
		  "	{",
		  "		Type a = value, b = mod(), u = 0, v = 1;",
		  "		while (a != 0)",
		  "		{",
		  "			Type t = b / a;",
		  "			b -= t * a;",
		  "			swap(a, b);",
		  "			u -= t * v;",
		  "			swap(u, v);",
		  "		}",
		  "		assert(b == 1);",
		  "		return Modular(u);",
		  "	}",
		  "	Modular &operator/=(const Modular &other) { return *this *= other.inverse(); }",
			"",
		  "	template <typename U>",
		  "	friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);",
			"",
		  "	template <typename U>",
		  "	friend std::istream &operator>>(std::istream &stream, Modular<U> &number);",
			"",
			"private:",
		  "	Type value;",
			"};",
			"",
			"template <typename T>",
			"bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }",
			"template <typename T, typename U>",
			"bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }",
			"template <typename T, typename U>",
			"bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }",
			"",
			"template <typename T>",
			"bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U>",
			"bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U>",
			"bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }",
			"",
			"template <typename T>",
			"Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }",
			"",
			"template <typename T>",
			"Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U>",
			"Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }",
			"",
			"template <typename T, typename U>",
			"Modular<T> power(const Modular<T> &a, const U &b)",
			"{",
		  "	assert(b >= 0);",
		  "	Modular<T> x = a, res = 1;",
		  "	U p = b;",
		  "	while (p > 0)",
		  "	{",
		  "		if (p & 1)",
		  "			res *= x;",
		  "		x *= x;",
		  "		p >>= 1;",
		  "	}",
		  "	return res;",
			"}",
			"",
			"template <typename T>",
			"string to_string(const Modular<T> &number)",
			"{",
		  "	return to_string(number());",
			"}",
			"",
			"template <typename T>",
			"std::ostream &operator<<(std::ostream &stream, const Modular<T> &number)",
			"{",
		  "	return stream << number();",
			"}",
			"",
			"template <typename T>",
			"std::istream &operator>>(std::istream &stream, Modular<T> &number)",
			"{",
		  "	typename common_type<typename Modular<T>::Type, int64_t>::type x;",
		  "	stream >> x;",
		  "	number.value = Modular<T>::normalize(x);",
		  "	//  stream >> number.value;",
		  "	//  number.value = Modular<T>::normalize(number.value);",
		  "	return stream;",
			"}",
			"",
			"/*",
			"using ModType = int;",
			"",
			"struct VarMod { static ModType value; };",
			"ModType VarMod::value;",
			"ModType& md = VarMod::value;",
			"using Mint = Modular<VarMod>;",
			"*/",
			"",
			"constexpr int md = MOD;",
			"using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;",
			"",
			"template <typename T>",
			"class NTT",
			"{",
			"public:",
		  "	using Type = typename decay<decltype(T::value)>::type;",
			"",
		  "	static Type md;",
		  "	static Modular<T> root;",
		  "	static int base;",
		  "	static int max_base;",
		  "	static vector<Modular<T>> roots;",
		  "	static vector<int> rev;",
			"",
		  "	static void clear()",
		  "	{",
		  "		root = 0;",
		  "		base = 0;",
		  "		max_base = 0;",
		  "		roots.clear();",
		  "		rev.clear();",
		  "	}",
			"",
		  "	static void init()",
		  "	{",
		  "		md = T::value;",
		  "		assert(md >= 3 && md % 2 == 1);",
		  "		auto tmp = md - 1;",
		  "		max_base = 0;",
		  "		while (tmp % 2 == 0)",
		  "		{",
		  "			tmp /= 2;",
		  "			max_base++;",
		  "		}",
		  "		root = 2;",
		  "		while (power(root, (md - 1) >> 1) == 1)",
		  "		{",
		  "			root++;",
		  "		}",
		  "		assert(power(root, md - 1) == 1);",
		  "		root = power(root, (md - 1) >> max_base);",
		  "		base = 1;",
		  "		rev = {0, 1};",
		  "		roots = {0, 1};",
		  "	}",
			"",
		  "	static void ensure_base(int nbase)",
		  "	{",
		  "		if (md != T::value)",
		  "		{",
		  "			clear();",
		  "		}",
		  "		if (roots.empty())",
		  "		{",
		  "			init();",
		  "		}",
		  "		if (nbase <= base)",
		  "		{",
		  "			return;",
		  "		}",
		  "		assert(nbase <= max_base);",
		  "		rev.resize(1 << nbase);",
		  "		for (int i = 0; i < (1 << nbase); i++)",
		  "		{",
		  "			rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));",
		  "		}",
		  "		roots.resize(1 << nbase);",
		  "		while (base < nbase)",
		  "		{",
		  "			Modular<T> z = power(root, 1 << (max_base - 1 - base));",
		  "			for (int i = 1 << (base - 1); i < (1 << base); i++)",
		  "			{",
		  "				roots[i << 1] = roots[i];",
		  "				roots[(i << 1) + 1] = roots[i] * z;",
		  "			}",
		  "			base++;",
		  "		}",
		  "	}",
			"",
		  "	static void fft(vector<Modular<T>> &a)",
		  "	{",
		  "		int n = (int)a.size();",
		  "		assert((n & (n - 1)) == 0);",
		  "		int zeros = __builtin_ctz(n);",
		  "		ensure_base(zeros);",
		  "		int shift = base - zeros;",
		  "		for (int i = 0; i < n; i++)",
		  "		{",
		  "			if (i < (rev[i] >> shift))",
		  "			{",
		  "				swap(a[i], a[rev[i] >> shift]);",
		  "			}",
		  "		}",
		  "		for (int k = 1; k < n; k <<= 1)",
		  "		{",
		  "			for (int i = 0; i < n; i += 2 * k)",
		  "			{",
		  "				for (int j = 0; j < k; j++)",
		  "				{",
		  "					Modular<T> x = a[i + j];",
		  "					Modular<T> y = a[i + j + k] * roots[j + k];",
		  "					a[i + j] = x + y;",
		  "					a[i + j + k] = x - y;",
		  "				}",
		  "			}",
		  "		}",
		  "	}",
			"",
		  "	static vector<Modular<T>> multiply(vector<Modular<T>> a, vector<Modular<T>> b)",
		  "	{",
		  "		if (a.empty() || b.empty())",
		  "		{",
		  "			return {};",
		  "		}",
		  "		int eq = (a.size() == b.size() && a == b);",
		  "		int need = (int)a.size() + (int)b.size() - 1;",
		  "		int nbase = 0;",
		  "		while ((1 << nbase) < need)",
		  "			nbase++;",
		  "		ensure_base(nbase);",
		  "		int sz = 1 << nbase;",
		  "		a.resize(sz);",
		  "		b.resize(sz);",
		  "		fft(a);",
		  "		if (eq)",
		  "			b = a;",
		  "		else",
		  "			fft(b);",
		  "		Modular<T> inv_sz = 1 / static_cast<Modular<T>>(sz);",
		  "		for (int i = 0; i < sz; i++)",
		  "		{",
		  "			a[i] *= b[i] * inv_sz;",
		  "		}",
		  "		reverse(a.begin() + 1, a.end());",
		  "		fft(a);",
		  "		a.resize(need);",
		  "		return a;",
		  "	}",
			"};",
			"",
			"template <typename T>",
			"typename NTT<T>::Type NTT<T>::md;",
			"template <typename T>",
			"Modular<T> NTT<T>::root;",
			"template <typename T>",
			"int NTT<T>::base;",
			"template <typename T>",
			"int NTT<T>::max_base;",
			"template <typename T>",
			"vector<Modular<T>> NTT<T>::roots;",
			"template <typename T>",
			"vector<int> NTT<T>::rev;",
			"",
			"template <typename T>",
			"vector<Modular<T>> inverse(const vector<Modular<T>> &a)",
			"{",
		  "	assert(!a.empty());",
		  "	int n = (int)a.size();",
		  "	vector<Modular<T>> b = {1 / a[0]};",
		  "	while ((int)b.size() < n)",
		  "	{",
		  "		vector<Modular<T>> x(a.begin(), a.begin() + min(a.size(), b.size() << 1));",
		  "		x.resize(b.size() << 1);",
		  "		b.resize(b.size() << 1);",
		  "		vector<Modular<T>> c = b;",
		  "		NTT<T>::fft(c);",
		  "		NTT<T>::fft(x);",
		  "		Modular<T> inv = 1 / static_cast<Modular<T>>((int)x.size());",
		  "		for (int i = 0; i < (int)x.size(); i++)",
		  "		{",
		  "			x[i] *= c[i] * inv;",
		  "		}",
		  "		reverse(x.begin() + 1, x.end());",
		  "		NTT<T>::fft(x);",
		  "		rotate(x.begin(), x.begin() + (x.size() >> 1), x.end());",
		  "		fill(x.begin() + (x.size() >> 1), x.end(), 0);",
		  "		NTT<T>::fft(x);",
		  "		for (int i = 0; i < (int)x.size(); i++)",
		  "		{",
		  "			x[i] *= c[i] * inv;",
		  "		}",
		  "		reverse(x.begin() + 1, x.end());",
		  "		NTT<T>::fft(x);",
		  "		for (int i = 0; i < ((int)x.size() >> 1); i++)",
		  "		{",
		  "			b[i + ((int)x.size() >> 1)] = -x[i];",
		  "		}",
		  "	}",
		  "	b.resize(n);",
		  "	return b;",
			"}",
			"",
			"template <typename T>",
			"vector<Modular<T>> inverse_old(vector<Modular<T>> a)",
			"{",
		  "	assert(!a.empty());",
		  "	int n = (int)a.size();",
		  "	if (n == 1)",
		  "	{",
		  "		return {1 / a[0]};",
		  "	}",
		  "	int m = (n + 1) >> 1;",
		  "	vector<Modular<T>> b = inverse_old(vector<Modular<T>>(a.begin(), a.begin() + m));",
		  "	int need = n << 1;",
		  "	int nbase = 0;",
		  "	while ((1 << nbase) < need)",
		  "	{",
		  "		++nbase;",
		  "	}",
		  "	NTT<T>::ensure_base(nbase);",
		  "	int size = 1 << nbase;",
		  "	a.resize(size);",
		  "	b.resize(size);",
		  "	NTT<T>::fft(a);",
		  "	NTT<T>::fft(b);",
		  "	Modular<T> inv = 1 / static_cast<Modular<T>>(size);",
		  "	for (int i = 0; i < size; ++i)",
		  "	{",
		  "		a[i] = (2 - a[i] * b[i]) * b[i] * inv;",
		  "	}",
		  "	reverse(a.begin() + 1, a.end());",
		  "	NTT<T>::fft(a);",
		  "	a.resize(n);",
		  "	return a;",
			"}",
			"",
			"template <typename T>",
			"vector<Modular<T>> operator*(const vector<Modular<T>> &a, const vector<Modular<T>> &b)",
			"{",
		  "	if (a.empty() || b.empty())",
		  "	{",
		  "		return {};",
		  "	}",
		  "	if (min(a.size(), b.size()) < 100)",
		  "	{",
		  "		vector<Modular<T>> c(a.size() + b.size() - 1, 0);",
		  "		for (int i = 0; i < (int)a.size(); i++)",
		  "		{",
		  "			for (int j = 0; j < (int)b.size(); j++)",
		  "			{",
		  "				c[i + j] += a[i] * b[j];",
		  "			}",
		  "		}",
		  "		return c;",
		  "	}",
		  "	return NTT<T>::multiply(a, b);",
			"}",
			"",
			"template <typename T>",
			"vector<Modular<T>> &operator*=(vector<Modular<T>> &a, const vector<Modular<T>> &b)",
			"{",
		  "	return a = a * b;",
			"}",
			"",
			"template <typename T>",
			"vector<T> &operator+=(vector<T> &a, const vector<T> &b)",
			"{",
		  "	if (a.size() < b.size())",
		  "	{",
		  "		a.resize(b.size());",
		  "	}",
		  "	for (int i = 0; i < (int)b.size(); i++)",
		  "	{",
		  "		a[i] += b[i];",
		  "	}",
		  "	return a;",
			"}",
			"",
			"template <typename T>",
			"vector<T> operator+(const vector<T> &a, const vector<T> &b)",
			"{",
		  "	vector<T> c = a;",
		  "	return c += b;",
			"}",
			"",
			"template <typename T>",
			"vector<T> &operator-=(vector<T> &a, const vector<T> &b)",
			"{",
		  "	if (a.size() < b.size())",
		  "	{",
		  "		a.resize(b.size());",
		  "	}",
		  "	for (int i = 0; i < (int)b.size(); i++)",
		  "	{",
		  "		a[i] -= b[i];",
		  "	}",
		  "	return a;",
			"}",
			"",
			"template <typename T>",
			"vector<T> operator-(const vector<T> &a, const vector<T> &b)",
			"{",
		  "	vector<T> c = a;",
		  "	return c -= b;",
			"}",
			"",
			"template <typename T>",
			"vector<T> operator-(const vector<T> &a)",
			"{",
		  "	vector<T> c = a;",
		  "	for (int i = 0; i < (int)c.size(); i++)",
		  "	{",
		  "		c[i] = -c[i];",
		  "	}",
		  "	return c;",
			"}",
			"",
			"// (x + 1) * (x + 2) * ... * (x + n)",
			"template <typename T>",
			"vector<T> sequence(int n)",
			"{",
		  "	if (n == 0)",
		  "	{",
		  "		return {1};",
		  "	}",
		  "	if (n % 2 == 1)",
		  "	{",
		  "		return sequence<T>(n - 1) * vector<T>{n, 1};",
		  "	}",
		  "	vector<T> c = sequence<T>(n / 2);",
		  "	vector<T> a = c;",
		  "	reverse(a.begin(), a.end());",
		  "	T f = 1;",
		  "	for (int i = n / 2 - 1; i >= 0; i--)",
		  "	{",
		  "		f *= n / 2 - i;",
		  "		a[i] *= f;",
		  "	}",
		  "	vector<T> b(n / 2 + 1);",
		  "	b[0] = 1;",
		  "	for (int i = 1; i <= n / 2; i++)",
		  "	{",
		  "		b[i] = b[i - 1] * (n / 2) / i;",
		  "	}",
		  "	vector<T> h = a * b;",
		  "	h.resize(n / 2 + 1);",
		  "	reverse(h.begin(), h.end());",
		  "	f = 1;",
		  "	for (int i = 1; i <= n / 2; i++)",
		  "	{",
		  "		f /= i;",
		  "		h[i] *= f;",
		  "	}",
		  "	vector<T> res = c * h;",
		  "	return res;",
			"}",
			"#pragma endregion",
			"vector<ll> calculatePolynomial(int n)",
			"{",
		  "	vector<Mint> coeff = sequence<Mint>(n);",
		  "	vector<ll> res(n+2, 0);",
		  "	for (int i = 0; i < coeff.size(); ++i)",
		  "	{",
		  "		#ifdef MOD",
		  "		res[i+1] = ((ll)(coeff[i])) % MOD;",
		  "		#else",
		  "		res[i+1] = ((ll)(coeff[i]));",
		  "		#endif",
		  "	}",
		  "	return res;",
			"}"
		],
		"description": "NTT"
	},
	"fft": {
		"prefix": "fft",
		"body": [
			"double PI = acos(0) * 2;",
			"class Complex",
			"{",
			"public:",
		  "	double a, b;",
		  "	Complex() {a = 0.0; b = 0.0;}",
		  "	Complex(double na, double nb) {a = na; b = nb;}",
		  "	const Complex operator+(const Complex &c) const",
		  "		{return Complex(a + c.a, b + c.b);}",
		  "	const Complex operator-(const Complex &c) const",
		  "		{return Complex(a - c.a, b - c.b);}",
		  "	const Complex operator*(const Complex &c) const",
		  "		{return Complex(a*c.a - b*c.b, a*c.b + b*c.a);}",
		  "	double magnitude() {return sqrt(a*a+b*b);}",
		  "	void print() {printf(\"(%.3f %.3f)\\n\", a, b);}",
			"};",
			"",
			"class FFT",
			"{",
			"public:",
		  "	vector<Complex> data;",
		  "	vector<Complex> roots;",
		  "	vector<int> rev;",
		  "	int s, n;",
		  "	void setSize(int ns)",
		  "	{",
		  "		s = ns;",
		  "		n = (1 << s);",
		  "		int i, j;",
		  "		rev = vector<int>(n);",
		  "		data = vector<Complex> (n);",
		  "		roots = vector<Complex> (n+1);",
		  "		for (i = 0; i < n; i++)",
		  "			for (j = 0; j < s; j++)",
		  "				if ((i & (1 << j)) != 0)",
		  "					rev[i] += (1 << (s-j-1));",
		  "		roots[0] = Complex(1, 0);",
		  "		Complex mult = Complex(cos(2*PI/n), sin(2*PI/n));",
		  "		for (i = 1; i <= n; i++)",
		  "			roots[i] = roots[i-1] * mult;",
		  "	}",
		  "	void bitReverse(vector<Complex> &array)",
		  "	{",
		  "		vector<Complex> temp(n);",
		  "		int i;",
		  "		for (i = 0; i < n; i++)",
		  "			temp[i] = array[rev[i]];",
		  "		for (i = 0; i < n; i++)",
		  "			array[i] = temp[i];",
		  "	}",
		  "	void transform(bool inverse = false)",
		  "	{",
		  "		bitReverse(data);",
		  "		int i, j, k;",
		  "		for (i = 1; i <= s; i++) {",
		  "			int m = (1 << i), md2 = m / 2;",
		  "			int start = 0, increment = (1 << (s-i));",
		  "			if (inverse) {",
		  "				start = n;",
		  "				increment *= -1;",
		  "			}",
		  "			Complex t, u;",
		  "			for (k = 0; k < n; k += m) {",
		  "				int index = start;",
		  "				for (j = k; j < md2+k; j++) {",
		  "					t = roots[index] * data[j+md2];",
		  "					index += increment;",
		  "					data[j+md2] = data[j] - t;",
		  "					data[j] = data[j] + t;",
		  "				}",
		  "			}",
		  "		}",
		  "		if (inverse)",
		  "			for (i = 0; i < n; i++) {",
		  "				data[i].a /= n;",
		  "				data[i].b /= n;",
		  "			}",
		  "	}",
		  "	static vector<int> convolution(vector<int> &a, vector<int> &b)",
		  "	{",
		  "		int alen = a.size(), blen = b.size();",
		  "		int resn = alen + blen - 1;	// size of the resulting array",
		  "		int s = 0, i;",
		  "		while ((1 << s) < resn) s++;	// n = 2^s",
		  "		int n = 1 << s;	// round up the the nearest power of two",
			"",
		  "		FFT pga, pgb;",
		  "		pga.setSize(s);	// fill and transform first array",
		  "		for (i = 0; i < alen; i++) pga.data[i] = Complex(a[i], 0);",
		  "		for (i = alen; i < n; i++)	pga.data[i] = Complex(0, 0);",
		  "		pga.transform();",
			"",
		  "		pgb.setSize(s);	// fill and transform second array",
		  "		for (i = 0; i < blen; i++)	pgb.data[i] = Complex(b[i], 0);",
		  "		for (i = blen; i < n; i++)	pgb.data[i] = Complex(0, 0);",
		  "		pgb.transform();",
			"",
		  "		for (i = 0; i < n; i++)	pga.data[i] = pga.data[i] * pgb.data[i];",
		  "		pga.transform(true);	// inverse transform",
		  "		vector<int> result = vector<int> (resn);	// round to nearest integer",
		  "		for (i = 0; i < resn; i++)	result[i] = (int) (pga.data[i].a + 0.5);",
			"",
		  "		int actualSize = resn - 1;	// find proper size of array",
		  "		while (result[actualSize] == 0)",
		  "			actualSize--;",
		  "		if (actualSize < 0) actualSize = 0;",
		  "		result.resize(actualSize+1);",
		  "		return result;",
		  "	}",
			"}; // <lowest_order> ... <highest_order>"
		],
		"description": "fft"
	},
	"zfunction": {
		"prefix": "zfunction",
		"body": [
			"vector<int> z_func(string s)",
			"{",
			"    int n = s.size();",
			"    vector<int> z(n, 0);",
			"    for (int i = 1, l = 0, r = 0; i < n; ++i)",
			"    {",
			"        if (i <= r) z[i] = min(r-i+1, z[i-l]);",
			"        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];",
			"        if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;",
			"    }",
			"    return z;",
			"}",
			"",
			"int patternCount(string s, string p, bool allowOverlap)",
			"{",
			"    auto z = z_func(p + '$' + s);",
			"    int count = 0;",
			"    for (int i = 0; i < z.size(); ++i)",
			"    {",
			"        if (z[i] == p.size())",
			"        {",
			"            count++;",
			"            if (!allowOverlap) i += p.size()-1;",
			"        }",
			"    }",
			"    return count;",
			"}",
			""
		],
		"description": "zfunction"
	},
	"Graph Matching": {
		"prefix": "graphMatching",
		"body": [
			"class GraphMatching",
			"{",
			"private:",
		  "	static bool findMatch(int i, const vector<vector<int>> &inp_w, vector<int> &out_row, vector<int> &out_column, vector<int> &seen)",
		  "	{",
		  "		// 0 is NO_EDGE here",
		  "		if (seen[i]) return false;",
		  "		seen[i] = true;",
		  "		for (int j = 0; j < inp_w[i].size(); ++j)",
		  "		{",
		  "			if (inp_w[i][j] != 0 && out_column[j] < 0)",
		  "			{",
		  "				out_row[i] = j, out_column[j] = i;",
		  "				return true;",
		  "			}",
		  "		}",
		  "		for (int j = 0; j < inp_w[i].size(); ++j)",
		  "		{",
		  "			if (inp_w[i][j] != 0 && out_row[i] != j)",
		  "			{",
		  "				if (out_column[j] < 0 || findMatch(out_column[j], inp_w, out_row, out_column, seen))",
		  "				{",
		  "					out_row[i] = j, out_column[j] = i;",
		  "					return true;",
		  "				}",
		  "			}",
		  "		}",
		  "		return false;",
		  "	}",
		  "	static bool dfs(int n, int N, vector<vector<int>> &inp_con, vector<int> &blossom, vector<int> &vis, vector<int> &out_match)",
		  "	{",
		  "		vis[n] = 0;",
		  "		for (int i = 0; i < N; ++i)",
		  "		{",
		  "			if (!inp_con[n][i]) continue;",
		  "			if (vis[i] == -1)",
		  "			{",
		  "				vis[i] = 1;",
		  "				if (out_match[i] == -1 || dfs(out_match[i], N, inp_con, blossom, vis, out_match))",
		  "				{",
		  "					out_match[n] = i, out_match[i] = n;",
		  "					return true;",
		  "				}",
		  "			}",
		  "			if (vis[i] == 0 || blossom.size())",
		  "			{",
		  "				blossom.push_back(i), blossom.push_back(n);",
		  "				if (n == blossom[0])",
		  "				{",
		  "					out_match[n] = -1;",
		  "					return true;",
		  "				}",
		  "				return false;",
		  "			}",
		  "		}",
		  "		return false;",
		  "	}",
		  "	static bool augment(int N, vector<vector<int>> &inp_con, vector<int> &out_match)",
		  "	{",
		  "		for (int i = 0; i < N; ++i)",
		  "		{",
		  "			if (out_match[i] != -1) continue;",
		  "			vector<int> blossom;",
		  "			vector<int> vis(N, -1);",
		  "			if (!dfs(i, N, inp_con, blossom, vis, out_match)) continue;",
		  "			if (blossom.size() == 0) return true;",
		  "			int base = blossom[0], S = blossom.size();",
		  "			vector<vector<int>> newCon = inp_con;",
		  "			for (int i = 1; i != S-1; ++i)",
		  "				for (int j = 0; j < N; ++j)",
		  "					newCon[base][j] = newCon[j][base] |= inp_con[blossom[i]][j];",
		  "			for (int i = 1; i != S-1; ++i)",
		  "				for (int j = 0; j < N; ++j)",
		  "					newCon[blossom[i]][j] = newCon[j][blossom[i]] = 0;",
		  "			newCon[base][base] = 0;",
		  "			if (!augment(N, newCon, out_match)) return false;",
		  "			int n = out_match[base];",
		  "			if (n != -1)",
		  "			{",
		  "				for (int i = 0; i < S; ++i)",
		  "				{",
		  "					if (!inp_con[blossom[i]][n]) continue;",
		  "					out_match[blossom[i]] = n, out_match[n] = blossom[i];",
		  "					if (i&1)",
		  "					{",
		  "						for (int j = i+1; j < S; j += 2)",
		  "							out_match[blossom[j]] = blossom[j+1], out_match[blossom[j+1]] = blossom[j];",
		  "					}",
		  "					else",
		  "					{",
		  "						for (int j = 0; j < i; j += 2)",
		  "							out_match[blossom[j]] = blossom[j+1], out_match[blossom[j+1]] = blossom[j];",
		  "					}",
		  "					break;",
		  "				}",
		  "			}",
		  "			return true;",
		  "		}",
		  "		return false;",
		  "	}",
			"public:",
		  "	/* weighted bipartite matching, inp_w[i][j] is cost from row node i to column node j",
		  "	out vector out_row & out_column is assignment for that node or -1 if unassigned",
		  "	It has a heuristic that will give excellent performance on complete graphs where rows <= columns. */",
		  "	static int bipartiteMatching(const vector<vector<int>> &inp_w, vector<int> &out_row, vector<int> &out_column)",
		  "	{",
		  "		out_row = vector<int> (inp_w.size(), -1);",
		  "		out_column = vector<int> (inp_w[0].size(), -1);",
		  "		vector<int> seen(inp_w.size());",
		  "		int count = 0;",
		  "		for (int i = 0; i < inp_w.size(); ++i)",
		  "		{",
		  "			fill(seen.begin(), seen.end(), 0);",
		  "			if (findMatch(i, inp_w, out_row, out_column, seen)) count++;",
		  "		}",
		  "		return count;",
		  "	}",
		  "	// unweighted inp_conn[i][j] = 1 for edge 0 otherwise, returns no. of edges in max matching",
		  "	static int nonBipartiteMatching(vector<vector<int>> &inp_con, vector<int> &out_match)",
		  "	{",
		  "		int res = 0;",
		  "		int N = inp_con.size();",
		  "		out_match = vector<int>(N, -1);",
		  "		while (augment(N, inp_con, out_match)) res++;",
		  "		return res;",
		  "	}",
			"};"
		],
		"description": "Graph Matching"
	},
	"dateGeorgianJullian": {
		"prefix": "dateGeorgianJullian",
		"body": [
			"int georgianDateToJullian(int m, int d, int y)",
			"{",
			"    return 1461 * (y + 4800 + (m - 14) / 12) / 4 +",
			"        367 * (m - 2 - (m - 14) / 12 * 12) / 12 - ",
			"        3 * ((y + 4900 + (m - 14) / 12) / 100) / 4 + ",
			"        d - 32075;",
			"}",
			"void jullianDateToGeorgian(int jd, int &m, int &d, int &y)",
			"{",
			"    int x, n, i, j;",
			"    x = jd + 68569;",
			"    n = 4 * x / 146097;",
			"    x -= (146097 * n + 3) / 4;",
			"    i = (4000 * (x + 1)) / 1461001;",
			"    x -= 1461 * i / 4 - 31;",
			"    j = 80 * x / 2447;",
			"    d = x - 2447 * j / 80;",
			"    x = j / 11;",
			"    m = j + 2 - 12 * x;",
			"    y = 100 * (n - 49) + i + x;",
			"}"
		],
		"description": "dateGeorgianJullian"
	},
	"geometry": {
		"prefix": "geometry",
		"body": [
			"const double EPS = 1e-7;",
			"struct Point",
			"{",
			"    double x, y, z;",
			"    Point() : x(0), y(0), z(0) { }",
			"    Point(double _x, double _y) : x(_x), y(_y), z(0) { }",
			"    Point(double _x, double _y, double _z) : x(_x), y(_y), z(_z) { }",
			"    Point operator+(const Point &p) { return Point(x+p.x, y+p.y, z+p.z); }",
			"    Point operator-(const Point &p) { return Point(x-p.x, y-p.y, z-p.z); }",
			"    Point operator*(double c) { return Point(x*c, y*c, z*c); }",
			"    Point operator/(double c) { return Point(x/c, y/c, z/c); }",
			"};",
			"typedef Point Vector;",
			"typedef pair<Point, Point> Line;",
			"typedef vector<Point> Polygon;",
			"struct Plane { double a, b, c, d; };  // ax + by + cz = d form",
			"double crossProduct(const Vector &a, const Vector &b) { return a.x * b.y - a.y * b.x; }",
			"double dotProduct(const Vector &a, const Vector &b) { return a.x * b.x + a.y * b.y; }",
			"double sqrDist(Point p, Point q) { return dotProduct(p-q, p-q); }",
			"",
			"// internal used functions",
			"vector< pair<double, double> > vec;",
			"double length(const Vector &a) { return sqrt(dotProduct(a, a)); }",
			"inline int dcmp(double x) { return (x > 1e-10) - (x < -(1e-10)); }",
			"inline void add(double x, double flag) { vec.push_back(make_pair(x, -flag)); }",
			"double get(Point &p, Vector &v, Point &q, Vector &w) { return crossProduct(w, p-q) / crossProduct(v, w); }",
			"void getSegmentIntersection(Point p, Vector v, Point q, Vector w)",
			"{",
			"    if (!dcmp(crossProduct(v, w)))",
			"    {",
			"        if (!dcmp(crossProduct(v, q-p)))",
			"        {",
			"            double l = dotProduct(v, q-p) / dotProduct(v, v);",
			"            double r = dotProduct(v, q+w-p) / dotProduct(v, v);",
			"            if (l > r) swap(l, r);",
			"            add(l, +1); add(r, -1);",
			"        }",
			"    }",
			"    else",
			"    {",
			"        static int num = 0;",
			"        double temp = get(q, w, p, v);",
			"        if (dcmp(temp) >= 0 && dcmp(temp-1) <= 0)",
			"        {",
			"            double rate = 1;",
			"            if (dcmp(temp) == 0 || dcmp(temp-1) == 0) rate = .5;",
			"            temp = get(p, v, q, w);",
			"            add(temp, dcmp(crossProduct(w, v)) > 0 ? +rate : -rate);",
			"        }",
			"    }",
			"}",
			"",
			"// Helper functions",
			"Point rotateCounterClockwise(Point pt, double radians) { return Point(pt.x*cos(radians) - pt.y*sin(radians), pt.x*sin(radians) + pt.y*cos(radians)); }",
			"Point rotateCounterClockwise(Point pt, double radians, Point ref) { return rotateCounterClockwise(pt-ref, radians)+ref; }",
			"Point rotateClockwise(Point pt, double radians) { return rotateCounterClockwise(pt, -radians); }",
			"Point rotateClockwise(Point pt, double radians, Point ref) { return rotateCounterClockwise(pt, -radians, ref); }",
			"double pointPlaneDistance(Point a, Plane b) { return fabs(b.a*a.x + b.b*a.y + b.c*a.z - b.d) / sqrt(b.a*b.a + b.b*b.b + b.c*b.c); }",
			"Point projectPointOnLine(Line a, Point b) { return a.F + (a.S-a.F) * dotProduct(b-a.F, a.S-a.F)/dotProduct(a.S-a.F, a.S-a.F); }",
			"Point projectPointOnLineSegment(Line a, Point b)",
			"{",
			"    double r = dotProduct(a.S-a.F, a.S-a.F);",
			"    if (fabs(r) < EPS) return a.F;",
			"    r = dotProduct(b-a.F, a.S-a.F)/r;",
			"    if (r < 0) return a.F;",
			"    if (r > 1) return a.S;",
			"    return a.F + (a.S-a.F)*r;",
			"}",
			"bool linesParalle(Line a, Line b) { return (fabs(crossProduct(a.S-a.F, b.F-b.S)) < EPS); }",
			"bool linesCollinear(Line a, Line b) { return (linesParalle(a, b) && (fabs(crossProduct(a.F-b.F, b.S-a.S)) < EPS)); }",
			"bool linesIntersect(Line a, Line b)",
			"{",
			"    if ((crossProduct(b.S-a.F, a.S-a.F) * crossProduct(b.F-a.F, a.S-a.F)) > 0) return false;",
			"    if ((crossProduct(a.F-b.F, b.S-b.F) * crossProduct(a.S-b.F, b.S-b.F)) > 0) return false;",
			"    return true;",
			"}",
			"Point computeLineIntersection(Line a, Line b)",
			"{",
			"    a.S = a.S-a.F; b.S = b.F-b.S; b.F = b.F-a.F;",
			"    if (dotProduct(a.S, a.S) < EPS) return a.F;",
			"    if (dotProduct(b.S, b.S) < EPS) return b.F;",
			"    return a.F + a.S*crossProduct(b.F, b.S)/crossProduct(a.S, b.S);",
			"}",
			"// Point in possibly non-convex polygon, returns 1 for strictly interior points,",
			"// 0 for strictly exterior points, and 0 or 1 for the remaining points",
			"bool pointInPolygon(const Polygon &poly, Point pt)",
			"{",
			"    bool res = false;",
			"    for (int i = 0; i < poly.size(); ++i)",
			"    {",
			"        int j = (i+1) % poly.size();",
			"        if ((poly[i].y <= pt.y && pt.y < poly[j].y || poly[j].y <= pt.x && pt.y < poly[i].y) &&",
			"            pt.x < poly[i].x + (poly[j].x - poly[i].x)*(pt.y - poly[i].y)/(poly[j].y - poly[i].y))",
			"            res = !res;",
			"    }",
			"    return res;",
			"}",
			"bool pointOnPolygon(const Polygon &poly, Point pt)",
			"{",
			"    for (int i = 0; i < poly.size(); ++i)",
			"    {",
			"        Line ln(poly[i], poly[(i+1)%poly.size()]);",
			"        if (sqrDist(projectPointOnLineSegment(ln, pt), pt) < EPS)",
			"            return true;",
			"    }",
			"    return false;",
			"}",
			"vector<Point> circleLineIntersection(Line line, Point center, double radius)",
			"{",
			"    vector<Point> res;",
			"    Point d = line.S-line.F;",
			"    double D = crossProduct(line.F-center, line.S-center);",
			"    double e = sqrt(radius*radius*dotProduct(d, d) - D*D);",
			"    res.push_back (center + Point(D*d.y+(d.y >= 0 ? 1 : -1)*d.x*e, -D*d.x+fabs(d.y)*e) / dotProduct(d,d));",
			"    if (e > 0) res.push_back (center + Point(D*d.y-(d.y >= 0 ? 1 : -1)*d.x*e,-D*d.x-fabs(d.y)*e) / dotProduct(d,d));",
			"    return res;",
			"}",
			"vector<Point> intersectionPointBetweenTwoCircles(Point a, Point b, double r, double R)",
			"{",
			"    vector<Point> ret;",
			"    double d = sqrt(sqrDist(a,b));",
			"    if (d > r+R || d+min(r,R) < max(r,R)) return ret;",
			"    double x = (d*d-R*R+r*r)/(2*d);",
			"    double y = sqrt(r*r-x*x);",
			"    Point v = (b-a)/d;",
			"    ret.push_back (a+v*x + rotateCounterClockwise(v, M_PI/2)*y);",
			"    if (y > 0) ret.push_back (a+v*x - rotateCounterClockwise(v, M_PI/2)*y);",
			"    return ret;",
			"}",
			"double areaBetweenTwoCircles(Point a, Point b, double r, double R)",
			"{",
			"    double n = sqrt((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));",
			"    if (n >= r+R) return 0;",
			"    else if (n+r <= R || n+R <= r) return (M_PI * min(r, R) * min(r, R));",
			"    else",
			"    {",
			"        double a = acos((R*R + n*n - r*r) / (2*R*n)) * 2;",
			"        double b = acos((r*r + n*n - R*R) / (2*r*n)) * 2;",
			"        return ((R*R*a + r*r*b - R*R*sin(a) - r*r*sin(b)) * 0.5);",
			"    }",
			"}",
			"// assuming that the coordinates are listed in a clockwise or counterclockwise order",
			"double polygonSignedArea(Polygon poly)",
			"{",
			"    double area = 0;",
			"    for (int i = 0; i < poly.size(); ++i)",
			"    {",
			"        int j = (i+1) % poly.size();",
			"        area += poly[i].x*poly[j].y - poly[j].x*poly[i].y;",
			"    }",
			"    return area / 2.0;",
			"}",
			"double polygonArea(Polygon poly) { return fabs(polygonSignedArea(poly)); }",
			"pair<double, double> polygonCentroid(Polygon poly)",
			"{",
			"    double cx = 0, cy = 0;",
			"    double scale = 6.0 * polygonSignedArea(poly);",
			"    for (int i = 0; i < poly.size(); ++i)",
			"    {",
			"        int j = (i+1) % poly.size();",
			"        cx += (poly[i].x+poly[j].x) * (poly[i].x*poly[j].y - poly[j].x*poly[i].y);",
			"        cy += (poly[i].y+poly[j].y) * (poly[i].x*poly[j].y - poly[j].x*poly[i].y);",
			"    }",
			"    return {cx/scale, cy/scale};",
			"}",
			"/*  Given a n side polygon (Not necessarily convex) and m lines, it finds section length",
			"    in nmlogn time. If the line fully lies inside the polygon it's that lines length, its",
			"    length that lies inside polygon. */",
			"vector<double> polygonLineIntersection(Polygon poly, vector<Line> lines)",
			"{",
			"    int n = poly.size(), m = lines.size(), x = 0;",
			"    poly.push_back(poly[0]);",
			"    vector<double> ans(m, 0);",
			"    for (auto &line : lines)",
			"    {",
			"        Point a = line.first, b = line.second;",
			"        vec.clear();",
			"        for (int i = 0; i < n; ++i)",
			"            getSegmentIntersection(a, b-a, poly[i], poly[i+1] - poly[i]);",
			"        sort(all(vec));",
			"        double k = 0;",
			"        for (size_t i = 0; i < vec.size(); ++i)",
			"        {",
			"            k += vec[i].second;",
			"            if (dcmp(k)) ans[x] += vec[i+1].first - vec[i].first;",
			"        }",
			"        ans[x++] *= length(b-a);",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "geometry"
	},
	"convexHull": {
		"prefix": "convexHull",
		"body": [
			"const int MAXN = 5e4 + 10;",
			"class ConvexHullDynamic",
			"{",
			"    typedef long long coef_t, coord_t, val_t;",
			"    //Line 'y=a*x+b' represented by 2 coefficients 'a' and 'b'",
			"private:",
			"    struct Line",
			"    {",
			"        coef_t a, b;",
			"        double xLeft;",
			"        enum Type { line, maxQuery, minQuery } type;",
			"        coord_t val;",
			"        explicit Line(coef_t aa = 0, coef_t bb = 0) : a(aa), b(bb), xLeft(-INFINITY), type(Type::line), val(0) {}",
			"        val_t valueAt(coord_t x) const { return a * x + b; }",
			"        friend bool areParallel(const Line &l1, const Line &l2) { return l1.a == l2.a; }",
			"        friend double intersectX(const Line &l1, const Line &l2) { return areParallel(l1, l2) ? INFINITY : 1.0 * (l2.b - l1.b) / (l1.a - l2.a); }",
			"        bool operator<(const Line &l2) const",
			"        {",
			"            if (l2.type == line) return this->a > l2.a;",
			"            if (l2.type == maxQuery) return this->xLeft < l2.val;",
			"            if (l2.type == minQuery) return this->xLeft > l2.val;",
			"            assert(0);",
			"            return false;",
			"        }",
			"    };",
			"    bool hasPrev(std::set<Line>::iterator it) { return it != hull.begin(); }",
			"    bool hasNext(std::set<Line>::iterator it) { return it != hull.end() && std::next(it) != hull.end(); }",
			"    bool irrelevant(const Line &l1, const Line &l2, const Line &l3) { return intersectX(l1, l3) <= intersectX(l1, l2); }",
			"    bool irrelevant(std::set<Line>::iterator it) { return hasPrev(it) && hasNext(it) && ((isMax && irrelevant(*std::prev(it), *it, *std::next(it))) || (!isMax && irrelevant(*std::next(it), *it, *std::prev(it)))); }",
			"    std::set<Line>::iterator updateLeftBorder(std::set<Line>::iterator it)",
			"    {",
			"        if ((isMax && !hasPrev(it)) || (!isMax && !hasNext(it))) return it;",
			"        double val = intersectX(*it, isMax ? *std::prev(it) : *std::next(it));",
			"        Line buf(*it);",
			"        it = hull.erase(it), buf.xLeft = val, it = hull.insert(it, buf);",
			"        return it;",
			"    }",
			"",
			"public:",
			"    bool isMax; //whether or not saved envelope is top(search of max value)",
			"    std::set<Line> hull; //envelope itself",
			"    explicit ConvexHullDynamic() : isMax(1) {} // true is for max and false is for min",
			"    void addLine(coef_t a, coef_t b)",
			"    {",
			"        Line l3 = Line(a, b);",
			"        auto it = hull.lower_bound(l3);",
			"        if (it != hull.end() && areParallel(*it, l3))",
			"        {",
			"            if ((isMax && it->b < b) || (!isMax && it->b > b)) it = hull.erase(it);",
			"            else return;",
			"        }",
			"        it = hull.insert(it, l3);",
			"        if (irrelevant(it)) { hull.erase(it); return; }",
			"        while (hasPrev(it) && irrelevant(std::prev(it))) hull.erase(std::prev(it));",
			"        while (hasNext(it) && irrelevant(std::next(it))) hull.erase(std::next(it));",
			"        it = updateLeftBorder(it);",
			"        if (hasPrev(it)) updateLeftBorder(std::prev(it));",
			"        if (hasNext(it)) updateLeftBorder(std::next(it));",
			"    }",
			"    val_t getBest(coord_t x) const",
			"    {",
			"        Line q;",
			"        q.val = x, q.type = isMax ? Line::Type::maxQuery : Line::Type::minQuery;",
			"        auto bestLine = hull.lower_bound(q);",
			"        if (isMax) --bestLine;",
			"        return bestLine->valueAt(x);",
			"    }",
			"};"
		],
		"description": "convexHull"
	},
	"slidingWindowMinMax": {
		"prefix": "slidingWindowMinMax",
		"body": [
			"vector<int> slidingWindowMinMax(vector<int> &arr, int k, bool max = true)",
			"{",
			"    deque<int> q;",
			"    vector<int> res;",
			"    int n = arr.size();",
			"    for(int i = 0; i < n; ++i)",
			"    {",
			"        while (!q.empty() && q.front() < i-k+1) q.pop_front();",
			"        if (max)",
			"        {",
			"            while (!q.empty() && arr[i] > arr[q.back()])",
			"                q.pop_back();",
			"        }",
			"        else",
			"        {",
			"            while (!q.empty() && arr[i] < arr[q.back()])",
			"                q.pop_back();",
			"        }",
			"        q.push_back(i);",
			"        if(i >= k-1) res.push_back(arr[q.front()]);",
			"    }",
			"    return res;",
			"}"
		],
		"description": "slidingWindowMinMax"
	},
	"nextMonotonicElement": {
		"prefix": "nextMonotonicElement",
		"body": [
			"vector<int> nextMonotonicElement(vector<int> &arr, bool greater = true, bool circularArray = false)",
			"{",
			"    vector<int> res(arr.size());",
			"    stack<int> st;",
			"    for (int i = (circularArray) ? (2*arr.size()-1) : (arr.size()-1); i >= 0; --i)",
			"    {",
			"        if (greater)",
			"        {",
			"            while (!st.empty() && arr[st.top()] <= arr[i % arr.size()])",
			"                st.pop();",
			"        }",
			"        else",
			"        {",
			"            while (!st.empty() && arr[st.top()] >= arr[i % arr.size()])",
			"                st.pop();",
			"        }",
			"        res[i % arr.size()] = st.empty() ? -1 : arr[st.top()];",
			"        st.push(i % arr.size());",
			"    }",
			"    return res;",
			"}"
		],
		"description": "nextMonotonicElement"
	},
	"largestHistogramArea": {
		"prefix": "largestHistogramArea",
		"body": [
			"int largestHistogramArea(vector<int>& arr)",
			"{",
			"    stack<int> st;",
			"    int ans = 0;",
			"    arr.push_back(-1);",
			"    for (int i = 0; i < arr.size(); ++i)",
			"    {",
			"        while (!st.empty() && arr[i] <= arr[st.top()])",
			"        {",
			"            int height = arr[st.top()]; st.pop();",
			"            int width = i - (st.empty() ? -1 : st.top()) - 1;",
			"            ans = max(ans, height * width);",
			"        }",
			"        st.push(i);",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "largestHistogramArea"
	},
	"shortestSubarrayWithSumAtleastK": {
		"prefix": "shortestSubarrayWithSumAtleastK",
		"body": [
			"int shortestSubarray(vector<int>& arr, int k, int &r, int &l)",
			"{",
			"    deque<pair<int, int>> dq;",
			"    dq.emplace_back(0, -1);",
			"    int presum = 0, res = INF;",
			"    for (int i = 0; i < arr.size(); ++ i)",
			"    {",
			"        presum += arr[i];",
			"        while(!dq.empty() && presum - dq.front().first >= k)",
			"        {",
			"            int cur = i-dq.front().second;",
			"            if (cur < res) res = cur, r = i, l = i-(cur-1);",
			"            dq.pop_front();",
			"        }",
			"        while(!dq.empty() && dq.back().first >= presum) dq.pop_back();",
			"        dq.emplace_back(presum, i);",
			"    }",
			"    return res == INF ? -1 : res;",
			"}"
		],
		"description": "shortestSubarrayWithSumAtleastK"
	},
	"LCA_query": {
		"prefix": "LCA_query",
		"body": [
			"#define MAXN 200005",
			"#define MAXLVL 25",
			"int lcaDepth[MAXN], lcaParent[MAXN][MAXLVL];",
			"void computeDepthAndParent(vector<int> adj[], int cur = 1, int par = 0)",
			"{",
    "	lcaDepth[cur] = lcaDepth[par]+1;",
    "	lcaParent[cur][0] = par;",
    "	for (auto &x : adj[cur])",
    "	{",
    "		if (x == par) continue;",
    "		computeDepthAndParent(adj, x, cur);",
    "	}",
			"}",
			"void preprocess(int n, vector<int> adj[])",
			"{",
    "	computeDepthAndParent(adj);",
    "	for (int i = 1; i < MAXLVL; ++i)",
    "		for (int j = 1; j <= n; ++j)",
    "			if (lcaParent[j][i-1] != -1) lcaParent[j][i] = lcaParent[lcaParent[j][i-1]][i-1];",
			"}",
			"int LCA(int u, int v)",
			"{",
    "	if (lcaDepth[v] < lcaDepth[u]) swap(u, v);",
    "	int diff = lcaDepth[v] - lcaDepth[u];",
    "	for (int i = 0; i < MAXLVL; ++i)",
    "		if ((diff>>i)&1) v = lcaParent[v][i];",
    "	if (u == v) return u;",
    "	for (int i = MAXLVL-1; i >= 0; --i)",
    "		if (lcaParent[u][i] != lcaParent[v][i]) u = lcaParent[u][i], lcaParent[v][i];",
    "	return lcaParent[u][0];",
			"}",
			"// Use 1 based indexing in adjancey list"
		],
		"description": "LCA_query"
	},
	"newtonMethod": {
		"prefix": "newtonMethod",
		"body": [
			"#define EPS 1e-7",
			"double f(double x) { return exp(-x); }",
		  "double fd(double x) { return -1 * exp(-x); }	// derrivative of f",
			"double bisection()",
			"{",
			"    double l = 0, r = 1;",
			"    while (l + EPS < r)",
			"    {",
			"        double mid = (l + r)/2;",
			"        if (f(l) * f(mid) <= 0) r = mid;",
			"        else l = mid;",
			"    }",
			"    return (l + r)/2;",
			"}",
			"double newton()",
			"{",
		  "	if (f(0) == 0) return 0;",
		  "	for (double x = 0.5; ;)",
		  "	{",
		  "		double x1 = x - f(x)/fd(x);",
		  "		if (fabs(x1-x) < EPS) return x;",
		  "		x = x1;",
		  "	}",
			"}"
		],
		"description": "newtonMethod"
	},
	"maxXorPair": {
		"prefix": "maxXorPair",
		"body": [
			"int maxXorPair(vector<int> &arr)",
			"{",
		  "	int mx = 0, mask = 0;",
		  "	set<int> st;",
		  "	for (int i = 60; i >= 0; --i)",
		  "	{",
		  "		mask |= (1<<i);",
		  "		for (auto &x : arr) st.insert(x & mask);",
		  "		int newMx = mx | (1<<i);",
		  "		for (auto x : st)",
		  "			if (st.count(newMx ^ x)) { mx = newMx; break; }",
		  "		st.clear();",
		  "	}",
		  "	return mx;",
			"}"
		],
		"description": "maxXorPair"
	},
	"DSU": {
		"prefix": "DSU",
		"body": [
			"const int MAXN = 1e5;",
			"int parent[MAXN+1], sz[MAXN+1];",
			"void makeSet(int x) { parent[x] = x, sz[x] = 1; }",
			"int findSet(int x) { return (x == parent[x]) ? x : parent[x] = findSet(parent[x]); }",
			"void unionSet(int x, int y)",
			"{",
		  "	x = findSet(x), y = findSet(y);",
		  "	if (x != y)",
		  "	{",
		  "		if (sz[x] < sz[y]) swap(x, y);",
		  "		parent[y] = x;",
		  "		sz[x] += sz[y];",
		  "	}",
			"}"
		],
		"description": "DSU"
	},
	"disjointSparseTable": {
		"prefix": "disjointSparseTable",
		"body": [
			"#define MAXN 1000000",
		  "#define MAXPOWN 1048576		// 2^(ceil(log_2(MAXN)))",
		  "#define MAXLVL 21			// ceil(log_2(MAXN)) + 1",
			"#define INIT sz = n; maxLvl = __builtin_clz(n) ^ 31; if((1<<maxLvl) != n) sz = 1<<++maxLvl;",
			"int n, p, maxLvl, sz, arr[MAXPOWN], sparseTable[MAXLVL][MAXPOWN];",
			"inline int func(int x, int y) { return min(x, y); }",
			"void build(int lvl = 0, int l = 0, int r = sz)",
			"{",
		  "	int m = (l+r)/2;",
		  "	sparseTable[lvl][m] = arr[m]%p;",
		  "	for (int i = m-1; i >= l; --i) sparseTable[lvl][i] = func(sparseTable[lvl][i+1], arr[i])%p;",
		  "	if (m+1 < r)",
		  "	{",
		  "		sparseTable[lvl][m+1] = arr[m+1]%p;",
		  "		for (int i = m+2; i < r; ++i) sparseTable[lvl][i] = func(sparseTable[lvl][i-1], arr[i])%p;",
		  "	}",
		  "	if (l+1 != r) { build(lvl+1, l, m); build(lvl+1, m, r); }",
			"}",
			"int query(int L, int R)",
			"{",
		  "	if (L == R) return arr[L]%p;",
		  "	int k = __builtin_clz(L^R) ^ 31;",
		  "	int lvl = maxLvl - 1 - k;",
		  "	int res = sparseTable[lvl][L];",
		  "	if (R & ((1<<k) - 1)) res = func(res, sparseTable[lvl][R])%p;",
		  "	return res;",
			"}"
		],
		"description": "disjointSparseTable"
	}
}