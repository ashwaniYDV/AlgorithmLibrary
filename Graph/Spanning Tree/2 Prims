// https://www.geeksforgeeks.org/prims-algorithm-using-priority_queue-stl/

const int N = 1e5+5;
int n, m;
vector<pair<int, int>> g[N];

void prims(int root) {
	vector<int> dp(n+1, INF);
	vector<int> parent(n+1, -1);
	vector<bool> inMST(n+1, false);

	// Create a priority queue to store vertices that are being preinMST
    priority_queue <pii, vector<pii>, greater<pii>> pq;
    pq.push({0, root});
    dp[root] = 0;

    int cost = 0;

    while(!pq.empty()) {
        int u = pq.top().second;
        cost += pq.top().first;
        pq.pop();

        inMST[u] = true;

        for(auto x: g[u]) {
        	int v = x.first;
            int weight = x.second;

            if (inMST[v] == false && dp[v] > weight) {
                // Updating dp of v
                dp[v] = weight;
                pq.push({dp[v], v});
                parent[v] = u;
            }
        }
    }

    cout << "Cost: " << cost << endl;

    // Print edges of MST using parent array
    for (int i = 1; i <= n; ++i) {
    	if(i == root) continue;
        cout << parent[i] << " " << i << endl;
    }
}

void solve() {
	int u, v, w;
	cin >> n >> m;
	f(i, m) {
		cin >> u >> v >> w;
		g[u].push_back({v, w});
		g[v].push_back({u, w});
	}
	// Taking root of MST as 1
	int root = 1;
	prims(root);
}
