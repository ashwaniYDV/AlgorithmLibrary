// https://www.spoj.com/problems/BVAAN/

/*
Find the maximum happiness that can be generated by the two strings.
The generated string is a common subsequence of length K of the two strings. 
Happiness of the string is calculated by the sum of ASCII values of characters in the string. 
If you are not able to generate a common subsequence of length K then the happiness is 0.  


Input:
First line consists of number of test cases t. 
Each test case consists of two strings b1 (blessing 1),b2 (blessing 2) and an integer K, each of them in separate lines.

Output"
Output consists of t lines each containing an integer denoting the maximum happiness value that can be generated by the two blessings.


Constraint
1 <= t <= 50
1 <= length(b1) , length(b2) <= 100 
1 <= K <= 100


Sample Input
2
asdf
asdf
3
anandi
jagya
3

Sample Output
317
0
*/


string s1, s2;
int k, n1, n2;

int go(int i, int j, int cnt, vector<vector<vector<int>>>& dp) {
    if (cnt == k) {
        return 0;
    }
    if (i == n1 || j == n2) {
        if (cnt < k) return -INF;
        return 0;
    }

    if (dp[i][j][cnt] != -1) return dp[i][j][cnt];

    int res = -INF;
    if (s1[i] == s2[j]) {
        res = max(res, s1[i] + go(i + 1, j + 1, cnt + 1, dp));
    }
    int x = go(i + 1, j, cnt, dp);
    int y = go(i, j + 1, cnt, dp);
    res = max({res, x, y});

    return dp[i][j][cnt] = res;
}

void solve() {
    cin >> s1 >> s2;
    cin >> k;
    n1 = s1.size(), n2 = s2.size();
    vector<vector<vector<int>>> dp(n1 + 1, vector<vector<int>>(n2 + 1, vector<int>(k + 1, -1)));
    int res = go(0, 0, 0, dp);
    cout << (res < 0 ? 0 : res) << endl;
}
